- "현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성돼 있다."라는, 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것이다.

## environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.

- environmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담긴다.
- 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 **순서대로** 수집한다.
- cf. 전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 객체, 즉 전역 객체를 활용한다. 전역 객체에는 브라우저의 window, Node.js의 global 객체 등이 있다. 이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류된다.
- 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈이다.

## 여기서 호이스팅이라는 개념이 등장한다.

- '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'라고 생각하더라도 코드를 해석하는 데는 문제될 것이 전혀 없을 것이다.

```javascript
// 원본 코드
function a (x) { // 수집 대상 1(매개변수)
  console.log(x) // (1)
  var x          // 수집 대상 2(변수 선언)
  console.log(x) // (2)
  var x = 2      // 수집 대상 3(변수 선언)
  console.log(x) // (3)
}
a(1)

// 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태
function a () {
  var x = 1      // 수집 대상 1(매개변수 선언)
  console.log(x) // (1)
  var x          // 수집 대상 2(변수 선언)
  console.log(x) // (2)
  var x = 2      // 수집 대상 3(변수 선언)
  console.log(x) // (3)
}
a()

// 호이스팅을 마친 상태
function a () {
  var x          // 수집 대상 1의 변수 선언 부분
  var x          // 수집 대상 2의 변수 선언 부분
  var x          // 수집 대상 3의 변수 선언 부분

  x = 1          // 수집 대상 1의 할당 부분
  console.log(x) // (1)
  console.log(x) // (2)
  x = 2          // 수집 대상 3의 할당 부분
  console.log(x) // (3)
}
a()
```

- 2번째 줄: 변수 x를 선언한다. 이때 메모리에서는 저장할 공간을 미리 확보하고, 확보한 공간의 주솟값을 변수 x에 연결해둔다.
- 3번째 줄과 4번째 줄: 다시 변수 x를 선언한다. 이미 선언된 변수 x가 있으므로 무시한다.
- 6번째 줄: x에 1을 할당하라고 한다. 우선 숫자 1을 별도의 메모리에 담고, x와 연결된 메모리 공간에 숫자 1을 가리키는 주솟값을 입력한다.
- 7번째 줄과 8번째 줄: 각 x를 출력하라고 한다. (1) (2) 모두 1이 출력된다.
- 9번째 줄: x에 2를 할당하라고 한다. 숫자 2를 별도의 메모리에 담고, 그 주솟값을 든 채로 x와 연결된 메모리 공간으로 간다. 여기에는 숫자 1을 가리키는 주솟값이 들어있었는데, 이걸 2의 주솟값으로 대치한다. 이제 변수 x를 숫자 2를 가리키게 된다.
- 10번째 줄: x를 출력하라고 하니 (3)에서는 2가 출력되고, 이제 함수 내부의 모든 코드가 실행됐으므로 실행 컨텍스트가 콜 스택에서 제거된다.

## 함수 선언을 추가한 예제

```javascript
// 원본 코드
function a () {
  console.log(b)    // (1)
  var b = 'bbb'     // 수집 대상 1(변수 선언)
  console.log(b)    // (2)
  function b () { } // 수집 대상 2(함수 선언)
  console.log(b)    // (3)
}
a()

// 호이스팅을 마친 상태 + 함수 선언문을 함수 표현식으로 바꾼 코드
function a () {
  var b                     // 수집 대상 1. 변수는 선언부만 끌어올린다.
  var b = function b () { } // 수집 대상 2. 함수 선언은 전체를 끌어올린다.

  console.log(b)            // (1)
  b = 'bbb'                 // 변수의 할당부는 원래 자리에 남겨둔다.
  console.log(b)            // (2)
  console.log(b)            // (3)
}
a()
```

- 2번째 줄: 변수 b를 선언한다. 이때 메모리에서는 저장할 공간을 미리 확보하고, 확보한 공간의 주솟값을 변수 b에 연결해둔다.
- 3번째 줄: 다시 변수 b를 선언하고 함수 b를 선언된 변수 b에 할당하라고 한다. 이미 선언된 변수 b가 있으므로 선언 과정은 무시한다. 함수는 별도의 메모리에 담길 것이고, 그 함수가 저장된 주솟값을 b와 연결된 공간에 저장한다. 이제 변수 b는 함수를 가리키게 된다.
- 5번째 줄: 변수 b에 할당된 함수 b를 출력한다(1).
- 6번재 줄: 변수 b에 'bbb'를 할당하라고 한다. b와 연결된 메모리 공간에는 함수가 저장된 주솟값이 담겨있었는데 이걸 문자열 'bbb'가 담긴 주솟값으로 덮어쓴다. 이제 변수 b는 문자열 'bbb'를 가리키게 된다.
- 7번째 줄과 8번째 줄: (2)와 (3) 모두 'bbb'가 출력되고, 이제 함수 내부의 모든 코드가 실행됐으므로 실행 컨텍스트가 콜 스택에서 제거된다.

## 함수 선언문과 함수 표현식

```javascript
function a () { /* ... */ } // 함수 선언문. 함수명 a가 곧 변수명.
a() // 실행 OK.

var b = function () { /* ... */ } // (익명) 함수 표현식. 변수명 b가 곧 함수명.
b() // 실행 OK.

var c = function d () { /* ... */ } // 기명 함수 표현식. 변수명은 c, 함수형은 d.
c() // 실행 OK.
d() // 에러!
```

- 함수명은 오직 함수 내부에서만 접근할 수 있다.
- 이제는 모든 브라우저들이 익명 함수 표현식의 변수명을 함수의 name 프로퍼티에 할당하고 있다.

```javascript
// 원본 코드
console.log(sum(1, 2))
console.log(multiply(3, 4))

function sum (a, b) { // 함수 선언문 sum
  return a + b
}

var multiply = function (a, b) { // 함수 표현식 multiply
  return a * b
}

// 호이스팅을 마친 상태
function sum (a, b) { // 함수 선언문은 전체를 호이스팅한다.
  return a + b
}

var multiply // 변수는 선언부만 끌어올린다.

console.log(sum(1, 2))
console.log(multiply(3, 4))

multiply = function (a, b) { // 변수의 할당부는 원래 자리에 남겨둔다.
  return a * b
}
```

- 함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅했다.
- 함수를 다른 변수에 값으로써 '할당'한 것이 곧 함수 표현식이다.
- 6번째 줄: 현재 multiply에는 값이 할당돼 있지 않다. 비어있는 대상을 함수로 여겨 실행하라고 명령한 것이다. 따라서 'multiply is not a function'이라는 에러 메시지가 출력된다. 뒤에 8번째 줄은 6번째 줄의 에러로 인해 실행되지 않은 채 런타임이 종료된다.

## 스코프란 식별자에 대한 유효범위다.

- A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근할 수 있다.
- ES5까지의 자바스크립트는 특이하게도 전역공간을 제외하면 오직 함수에 의해서만 스코프가 생성된다.
- 이러한 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 한다. 그리고 이를 가능케 하는 것이 바로 LexicalEnvironment의 두 번째 수집 자료인 `outerEnvironmentReference`다.

## outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조한다.

- '선언하다'라는 행위가 실제로 일어날 수 있는 시점이란 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐이다.
- 예를 들어, A 함수 내부에 B 함수를 선언하고 다시 B 함수 내부에 C 함수를 선언한 경우, 함수 C의 outerEnvironmentReference는 함수 B의 LexicalEnvironment를 참조한다. 함수 B의 outerEnvironmentReference는 함수 A의 LexicalEnvironment를 참조한다.
- 이처럼 outerEnvironmentReference는 연결리스트 형태를 띤다. '선언 시점의 LexicalEnvironment'를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 거다.
- 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하게 된다.

## 전역 공간에서 선언한 변수는 전역변수이고, 함수 내부에서 선언한 변수는 무조건 지역변수다.

- 코드의 안전성을 위해 가급적 전역변수 사용을 최소화하고자 노력하는 것이 좋겠다.
