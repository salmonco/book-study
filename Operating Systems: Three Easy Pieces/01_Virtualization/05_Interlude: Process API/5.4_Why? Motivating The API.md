왜 우리는 새로운 프로세스를 만드는 단순한 행위에 대해 그렇게 이상한 인터페이스를 구축했을까?

fork()와 exec()의 분리는 UNIX shell을 구축하는 데 필수적이다.

왜냐하면 fork() 호출 후 exec() 호출 전에 shell이 코드를 실행할 수 있기 때문이다.

이 코드는 곧 실행될 프로그램의 환경을 변경할 수 있으며, 따라서 다양한 흥미로운 기능을 쉽게 구축할 수 있게 해준다.

shell은 단지 사용자 프로그램일 뿐이다.

shell은 당신이 무언가 입력하기를 기다린다.

그런 다음 명령(즉, 실행 프로그램의 이름과 인수)을 입력한다.

대부분의 경우 shell은 파일 시스템에서 실행 파일이 있는 위치를 파악하여 fork()를 호출하여 명령을 실행할 새 자식 프로세스를 만들고 명령을 실행하기 위해 exec()의 일부 변형을 호출한 다음 wait()을 호출하여 명령이 완료될 때까지 기다린다.

자식이 완료되면, shell은 wait()에서 다시 돌아오고 프롬프트를 다시 출력하여 다음 명령을 준비한다.

fork()와 exec()의 분리는 shell이 오히려 쉽게 많은 유용한 것들을 할 수 있게 해준다. 예를 들면:

```shell
prompt > wc p3.c > newfile.txt
```

위의 예에서, 프로그램의 출력은 출력 파일 newfile.txt로 리디렉션된다.

shell이 이 작업을 수행하는 방법은 매우 간단하다.

자식이 생성되면 exec()을 호출하기 전에 shell은 표준 출력(standard output)을 닫고 newfile.txt 파일을 연다.

그렇게 함으로써 곧 실행될 프로그램의 모든 출력은 화면이 아닌 파일로 전송된다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/56975ea9-84d9-4b70-9531-16ef5ae2d8e3" />

위 그림은 정확히 이것을 하는 프로그램을 보여준다.

이 리디렉션이 작동하는 이유는 운영체제가 파일 설명자(file descriptor)를 관리하는 방법에 대한 가정 때문이다.

특히, UNIX 시스템은 0에서 free 파일 설명자를 찾기 시작한다.

이 경우, STDOUT_FILENO는 가장 먼저 사용 가능한 것이 될 것이며 따라서 open()이 호출될 때 할당된다.

예를 들어 printf()와 같은 루틴에 의해 표준 출력 파일 설명자에 대한 자식 프로세스의 후속 쓰기는 화면 대신 새로 열린 파일로 투명하게 라우팅된다.

다음은 p4.c 프로그램을 실행한 결과다:

<img width="500" alt="" src="https://github.com/user-attachments/assets/874e17cf-0d66-4194-ab44-bb12ea9bf475" />


당신은 이 출력에 대해 (적어도) 두 가지 흥미로운 정보를 발견할 것이다.

먼저, p4가 실행되면 아무 일도 없었던 것처럼 보인다.

shell은 명령 프롬프트를 출력하고 다음 명령을 즉시 사용할 준비가 된다.

그러나 그렇지 않다.

프로그램 p4는 실제로 fork()를 호출하여 새로운 자식을 생성한 다음, execvp() 호출을 통해 wc 프로그램을 실행했다.

파일 p4 출력으로 리디렉션되었기 때문에 화면에 출력이 보이지 않는다.

둘째, 출력 파일을 cat하면 실행 중인 wc에서 예상되는 모든 출력이 발견된다는 것을 알 수 있다.

UNIX 파이프는 비슷한 방식으로 구현되지만 pipe() system call로 구현된다.

이 경우 한 프로세스의 출력은 커널 내 파이프(즉, queue)에 연결되고, 다른 프로세스의 입력은 동일한 파이프에 연결된다.

따라서 한 프로세스의 출력은 다음 프로세스의 입력으로 원활하게 사용되며, 길고 유용한 명령 체인을 함께 묶을 수 있다.

간단한 예로, 파일에서 단어를 찾은 다음 해당 단어가 몇 번 발생하는지 세어 보는 것을 고려해보자.

파이프와 유틸리티 grep와 wc를 사용하면 쉽다.

명령 프롬프트에 아래 명령을 입력하고 결과에 감탄해보라.

```shell
grep -o foo file | wc -l
```

마지막으로, 우리는 단지 높은 수준에서 프로세스 API를 스케치했지만, 배우고 소화해야 할 이러한 호출에 대한 더 많은 세부 사항이 있다.

예를 들어 책의 세 번째 부분에서 파일 시스템에 대해 이야기할 때 파일 설명자에 대해 더 많이 배울 것이다.

현재로서는 fork() / exec() 조합이 프로세스를 생성하고 조작하는 강력한 방법이라고 말하는 것으로 충분하다.
