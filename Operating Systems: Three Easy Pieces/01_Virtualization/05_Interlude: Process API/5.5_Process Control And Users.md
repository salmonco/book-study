fork(), exec() 및 wait() 외에도 UNIX 시스템의 프로세스와 상호작용하기 위한 다른 많은 인터페이스가 있다.

예를 들어 kill() system call 호출은 일시 정지, 죽기 및 기타 유용한 명령어를 포함하여 프로세스에 signal을 보내는 데 사용된다.

편의를 위해 대부분의 UNIX shell에서 특정 키 입력 조합은 현재 실행 중인 프로세스에 특정 signal을 전달하도록 구성되어 있다.

예를 들어, control-c는 SIGINT (interrupt)를 보내고 (일반적으로 종료) control-z는 SIGSTP (stop) signal을 전송하여 실행 중에 프로세스를 일시 중지한다(예: 많은 shell에서 볼 수 있는 fg 내장 명령과 같은 명령으로 나중에 다시 시작할 수 있다).

전체 signal 하위 시스템은 개별 프로세스 내에서 해당 signal을 수신하고 처리하는 방법과 개별 프로세스 및 전체 프로세스 그룹에 signal을 보내는 방법을 포함하여 프로세스에 외부 이벤트를 전달할 수 있는 풍부한 인프라를 제공한다.

이러한 형태의 소통을 사용하려면 프로세스는 다양한 signal을 "캐치"하기 위해 signal() system call을 사용해야 한다.

**그렇게 하면 특정 signal이 프로세스에 전달될 때 정상적인 실행을 일시 중지하고 signal에 대한 응답으로 특정 코드를 실행한다.**

누가 프로세스에 signal을 보낼 수 있고, 누가 할 수 없는가?

일반적으로 우리가 사용하는 시스템은 여러 사람이 동시에 사용할 수 있다.

이 사람들 중 한 명이 SIGINT (프로세스를 중단하고 종료할 가능성이 있음)와 같은 signal을 임의로 보낼 수 있다면 시스템의 유용성과 보안이 손상될 것이다.

결과적으로 현대 시스템에는 사용자 개념에 대한 강력한 개념이 포함되어 있다.

사용자는 암호를 입력하여 자격 증명을 설정한 후 시스템 리소스에 액세스하기 위해 로그인한다.

그런 다음 사용자는 하나 또는 여러 개의 프로세스를 시작하고 이를 완전히 제어할 수 있다(일시 정지, 종료 등).

사용자는 일반적으로 자신의 프로세스만 제어할 수 있다.

전반적인 시스템 목표를 달성하기 위해 리소스(예: CPU, 메모리 및 디스크)를 각 사용자(및 프로세스)에게 분배하는 것은 운영체제의 임무다.
