이 막간에서 우리는 UNIX 시스템에서 프로세스 생성에 대해 논의한다.

UNIX는 한 쌍의 system call로 새로운 프로세스를 만드는 가장 흥미로운 방법 중 하나를 제시한다: fork() 및 exec()

세 번째 루틴인 wait()은 생성된 프로세스가 완료될 때까지 기다리기를 원하는 프로세스에서 사용할 수 있다.

---

fork() system call은 새로운 프로세스를 생성하는 데 사용된다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/8a8cfe74-8829-42dd-8a71-8c8d148a79a5" />

p1.c에서 무슨 일이 일어났는지 더 자세히 이해해보자.

처음 실행을 시작하면 프로세스는 hello world 메시지를 출력한다.

그 메시지에는 PID라고도 알려진 프로세스 식별자가 포함되어 있다.

프로세스의 PID는 29146이다.

UNIX 시스템에서 PID는 (예를 들어) 실행 중지와 같이 프로세스로 무언가를 수행하려는 경우 프로세스 이름을 지정하는 데 사용된다.

이제 흥미로운 부분이 시작된다.

프로세스는 OS가 새로운 프로세스를 생성하는 방법으로 제공하는 fork() system call을 호출한다.

생성된 프로세스는 호출 프로세스의 (거의) 정확한 사본이다.

즉, OS에는 이제 실행 중인 프로그램 p1의 두 복사본이 있는 것처럼 보이며, 둘 다 fork() system call에서 반환되려고 한다.

눈치챘을 수도 있다: 그 자식은 정확한 사본이 아니다.

구체적으로, 이제 자체 주소 공간(address space, 자체 개인 메모리), 자체 레지스터, 자체 PC 등을 가지고 있지만 fork() 호출자에게 반환되는 값은 다르다.

특히, 부모가 새로 생성된 자식의 PID를 받는 동안, 자식은 0의 반환 코드를 받는다.

이 차이점은 두 가지 다른 경우를 처리하는 코드를 작성할 때 유용하다(위와 같이).

당신은 또한 눈치챘을 것이다: (p1.c의) 출력은 결정적(deterministic)이지 않다.

자식 프로세스가 생성될 때, 이제 시스템에 우리가 관심을 갖는 두 개의 활성 프로세스가 있다: 부모와 자식

(단순성을 위해) 단일 CPU가 있는 시스템에서 실행되고 있다고 가정하면, 자식 또는 부모 중 하나가 그 시점에서 실행될 수 있다.

위 예에서, 부모가 그렇게 했기 때문에 메시지를 먼저 출력했다.

다른 경우에는 아래 출력에서 보여주는 것처럼 그 반대가 발생할 수 있다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/24976828-91da-455b-8391-982c7a940b80" />

CPU 스케줄러는 주어진 순간에 실행되는 프로세스를 결정한다.

스케줄러는 복잡하기 때문에 일반적으로 무엇을 선택할지, 어떤 프로세스가 먼저 실행될지에 대해 강력한 가정을 할 수 없다.

이러한 비결정론(non-determinism)은, 특히 다중 스레드 프로그램에서 몇 가지 흥미로운 문제로 이어진다.

따라서 우리는 책의 두 번째 부분에서 동시성(concurrency)를 연구할 때 훨씬 더 많은 비결정론을 보게 될 것이다.
