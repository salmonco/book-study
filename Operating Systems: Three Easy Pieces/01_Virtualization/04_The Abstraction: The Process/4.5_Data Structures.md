OS는 프로그램이며, 다른 프로그램과 마찬가지로 다양한 관련 정보를 추적하는 몇 가지 주요 데이터 구조를 가지고 있다.

예를 들어, 각 프로세스의 상태를 추적하기 위해 OS는 ready 상태의 모든 프로세스에 대한 일종의 프로세스 목록과 현재 ready 상태인 프로세스를 추적하기 위한 몇 가지 추가 정보를 유지할 것이다.

OS는 또한 어떤 식으로든 blocked 프로세스를 추적해야 한다.

I/O 이벤트가 완료되면 OS는 올바른 프로세스를 깨우고 다시 실행할 수 있도록 준비해야 한다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/ff398f6a-26c4-4de4-a75a-4f9861a8f34e" />

위 그림은 OS가 xv6 커널의 각 프로세스에 대해 추적해야 하는 정보 유형을 보여준다.

비슷한 프로세스 구조는 Linux, Mac OS X 또는 Windows와 같은 "실제" 운영체제에도 존재한다.

그림에서 OS가 프로세스에 대해 추적하는 몇 가지 중요한 정보를 볼 수 있다.

레지스터 컨텍스트는 중지된 프로세스에 대해 해당 레지스터의 내용을 보관한다.

프로세스가 중지되면 레지스터가 이 메모리 위치에 저장된다.

이러한 레지스터를 복원(값을 실제 물리적 레지스터에 다시 배치)함으로써 OS는 프로세스 실행을 재개할 수 있다(컨텍스트 스위치).

또한 그림에서 프로세스가 running, ready 및 blocked 상태 외에 다른 상태가 있을 수 있음을 알 수 있다.

때로는 시스템이 생성될 때 프로세스가 있는 초기 상태를 가질 수 있다.

또한, 프로세스는 종료되었지만 아직 정리되지 않은 final 상태에 놓일 수 있다(UNIX 기반 시스템에서는 좀비 상태라고 한다).

이 final 상태는 다른 프로세스(일반적으로 프로세스를 생성한 부모)가 프로세스의 반환 코드를 검사하고 방금 완료된 프로세스가 성공적으로 실행되었는지 확인할 수 있게 해주기 때문에 유용할 수 있다(일반적으로 UNIX 기반 시스템에서 프로그램은 작업을 성공적으로 완료했을 때 0을 반환하고, 그렇지 않으면 0이 아니다).

완료되면 부모는 자식 프로세스가 완료될 때까지 기다리기 위해 마지막 호출(예: wait())을 하고, 현재 사라진 프로세스를 참조하는 관련 데이터 구조를 정리할 수 있음을 OS에 알린다.
