프로세스는 Running, Ready, Blocked의 세 가지 상태 중 하나에 있을 수 있다.

### Running

running 상태에서는, 프로세스가 프로세서에서 실행 중이다.

이는 명령어를 실행하고 있다는 것을 의미한다.

### Ready

ready 상태에서는, 프로세스가 실행할 준비가 되었지만 어떤 이유로 OS가 이 순간에 실행하지 않기로 결정한 것이다.

### Blocked

blocked 상태에서는, 프로세스가 다른 이벤트가 발생할 때까지 실행할 준비가 되지 않는 일종의 작업을 수행했다.

일반적인 예로, 프로세스가 디스크에 I/O 요청을 시작하면 blocked 되고 따라서 다른 프로세스가 프로세서를 사용할 수 있게 된다.

---

<img width="300" alt="" src="https://github.com/user-attachments/assets/7d8bb5f6-c342-45d8-b04f-e498122496c7" />

위 다이어그램에서 볼 수 있듯이 OS의 재량에 따라 프로세스가 ready 상태와 running 상태 사이를 이동할 수 있다.

ready에서 running으로 이동하는 것은 프로세스가 scheduled 되었음을 의미한다.

running에서 ready로 이동하는 것은 프로세스가 descheduled 되었음을 의미한다.

프로세스가 blocked 되면(예: I/O 작업을 시작함으로써) OS는 어떤 이벤트가 발생할 때까지(예: I/O 완료) 그대로 유지한다.

그 시점에서 프로세스는 다시 ready 상태로 이동한다(OS가 그렇게 결정하면 잠재적으로 즉시 다시 실행된다).

<img width="500" alt="" src="https://github.com/user-attachments/assets/339565c4-d963-4360-a504-0b4973e59943" />

위 예제에서는 첫 번째 프로세스가 일정 시간 동안 실행된 후 I/O 작업을 수행한다.

그 시점에서 프로세스가 blocked 되어 다른 프로세스가 실행될 기회를 준다.

구체적으로, Process0은 I/O를 시작하고 완료를 기다리는 동안 blocked 된다.

예를 들어 디스크에서 읽거나 네트워크에서 패킷을 기다릴 때 프로세스가 blocked 된다.

OS는 Process0가 CPU를 사용하지 않고 있음을 인식하고 Process1을 실행하기 시작한다.

Process1이 실행되는 동안 I/O가 완료되어 Process0가 다시 ready 상태로 이동한다.

마지막으로, Process1이 완료된 후에 Process0가 실행되고 완료된다.

---

이 간단한 예에서도 OS가 내려야 하는 많은 결정이 있다는 점에 유의하라.

먼저, Process0가 I/O 작업을 수행하는 동안 시스템은 Process1을 실행하기로 결정해야 했다.

그렇게 하면 CPU를 바쁘게 유지하여 리소스 활용도가 향상된다.

둘째, 시스템은 I/O가 완료될 때 Process0으로 다시 전환하지 않기로 결정했다.

이것이 좋은 결정인지 아닌지는 분명하지 않다.

이러한 유형의 결정은 OS 스케줄러에 의해 이루어진다.
