- "현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성돼 있다."라는, 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것이다.

## environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.

- environmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담긴다.
- 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 **순서대로** 수집한다.
- cf. 전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 객체, 즉 전역 객체를 활용한다. 전역 객체에는 브라우저의 window, Node.js의 global 객체 등이 있다. 이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류된다.
- 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈이다.

## 여기서 호이스팅이라는 개념이 등장한다.

- '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'라고 생각하더라도 코드를 해석하는 데는 문제될 것이 전혀 없을 것이다.

```javascript
// 원본 코드
function a (x) { // 수집 대상 1(매개변수)
  console.log(x) // (1)
  var x          // 수집 대상 2(변수 선언)
  console.log(x) // (2)
  var x = 2      // 수집 대상 3(변수 선언)
  console.log(x) // (3)
}
a(1)

// 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태
function a () {
  var x = 1      // 수집 대상 1(매개변수 선언)
  console.log(x) // (1)
  var x          // 수집 대상 2(변수 선언)
  console.log(x) // (2)
  var x = 2      // 수집 대상 3(변수 선언)
  console.log(x) // (3)
}
a()

// 호이스팅을 마친 상태
function a () {
  var x          // 수집 대상 1의 변수 선언 부분
  var x          // 수집 대상 2의 변수 선언 부분
  var x          // 수집 대상 3의 변수 선언 부분

  x = 1          // 수집 대상 1의 할당 부분
  console.log(x) // (1)
  console.log(x) // (2)
  x = 2          // 수집 대상 3의 할당 부분
  console.log(x) // (3)
}
a()
```

- 2번째 줄: 변수 x를 선언한다. 이때 메모리에서는 저장할 공간을 미리 확보하고, 확보한 공간의 주솟값을 변수 x에 연결해둔다.
- 3번째 줄과 4번째 줄: 다시 변수 x를 선언한다. 이미 선언된 변수 x가 있으므로 무시한다.
- 6번째 줄: x에 1을 할당하라고 한다. 우선 숫자 1을 별도의 메모리에 담고, x와 연결된 메모리 공간에 숫자 1을 가리키는 주솟값을 입력한다.
- 7번째 줄과 8번째 줄: 각 x를 출력하라고 한다. (1) (2) 모두 1이 출력된다.
- 9번째 줄: x에 2를 할당하라고 한다. 숫자 2를 별도의 메모리에 담고, 그 주솟값을 든 채로 x와 연결된 메모리 공간으로 간다. 여기에는 숫자 1을 가리키는 주솟값이 들어있었는데, 이걸 2의 주솟값으로 대치한다. 이제 변수 x를 숫자 2를 가리키게 된다.
- 10번째 줄: x를 출력하라고 하니 (3)에서는 2가 출력되고, 이제 함수 내부의 모든 코드가 실행됐으므로 실행 컨텍스트가 콜 스택에서 제거된다.

## 함수 선언을 추가한 예제

```javascript
// 원본 코드
function a () {
  console.log(b)    // (1)
  var b = 'bbb'     // 수집 대상 1(변수 선언)
  console.log(b)    // (2)
  function b () { } // 수집 대상 2(함수 선언)
  console.log(b)    // (3)
}
a()

// 호이스팅을 마친 상태 + 함수 선언문을 함수 표현식으로 바꾼 코드
function a () {
  var b                     // 수집 대상 1. 변수는 선언부만 끌어올린다.
  var b = function b () { } // 수집 대상 2. 함수 선언은 전체를 끌어올린다.

  console.log(b)            // (1)
  b = 'bbb'                 // 변수의 할당부는 원래 자리에 남겨둔다.
  console.log(b)            // (2)
  console.log(b)            // (3)
}
a()
```

- 2번째 줄: 변수 b를 선언한다. 이때 메모리에서는 저장할 공간을 미리 확보하고, 확보한 공간의 주솟값을 변수 b에 연결해둔다.
- 3번째 줄: 다시 변수 b를 선언하고 함수 b를 선언된 변수 b에 할당하라고 한다. 이미 선언된 변수 b가 있으므로 선언 과정은 무시한다. 함수는 별도의 메모리에 담길 것이고, 그 함수가 저장된 주솟값을 b와 연결된 공간에 저장한다. 이제 변수 b는 함수를 가리키게 된다.
- 5번째 줄: 변수 b에 할당된 함수 b를 출력한다(1).
- 6번재 줄: 변수 b에 'bbb'를 할당하라고 한다. b와 연결된 메모리 공간에는 함수가 저장된 주솟값이 담겨있었는데 이걸 문자열 'bbb'가 담긴 주솟값으로 덮어쓴다. 이제 변수 b는 문자열 'bbb'를 가리키게 된다.
- 7번째 줄과 8번째 줄: (2)와 (3) 모두 'bbb'가 출력되고, 이제 함수 내부의 모든 코드가 실행됐으므로 실행 컨텍스트가 콜 스택에서 제거된다.
