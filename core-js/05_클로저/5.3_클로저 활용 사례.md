### 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

```javascript
// (1) 콜백 함수를 내부함수로 선언해서 외부변수를 직접 참조하는 방법 - 클로저 발생 O
var fruits = ['apple', 'banana', 'peach']
var $ul = document.createElement('ul')        // (공통 코드)

fruits.forEach(function (fruit) {             // (A)
  var $li = document.createElement('li')
  $li.innerText = fruit
  $li.addEventListener('click', function () { // (B)
    alert('your choice is ' + fruit)
  })
  $ul.appendChild($li)
})
document.body.appendChild($ul)
```

- addEventListener에 넘겨준 콜백 함수(B)에는 fruit이라는 외부 변수를 참조하고 있으므로 클로저가 있다.
- 클릭 이벤트에 의해 각 컨텍스트의 (B)가 실행될 때는 (B)의 outerEnvironmentReference가 (A)의 LexicalEnvironment를 참조하게 된다.
- 따라서 최소한 (B) 함수가 참조할 예정인 변수 fruit에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능할 것이다.

### 공통 함수로 쓰고자 콜백 함수를 외부로 꺼내어, fruit를 인자로 받아 출력하는 형태로 바꾸어 보자.

```javascript
// (2) bind 메서드로 값을 직접 넘겨주는 방법 - 클로저 발생 X. but 제약사항 발생
var alertFruit = function (fruit) {
  alert('your choice is ' + fruit)
}
fruits.forEach(function (fruit) {
  var $li = document.createElement('li')
  $li.innerText = fruit
  $li.addEventListener('click', alertFruit.bind(null, fruit))
  $ul.appendChild($li)
})
document.body.appendChild($ul)
alertFruit(fruits[1])
```

- 공통 함수로 쓰고자 콜백 함수를 외부로 꺼내어 alerFruit라는 변수에 담았다.
  - 근데 각 li를 클릭하면 클릭한 대상의 과일명이 아닌 \[object MouseEvent]라는 값이 출력된다.
  - 콜백 함수의 인자에 대한 제어권을 addEventListener가 가진 상태이며, addEventListener는 콜백 함수를 호출할 때 첫 번째 인자에 '이벤트 객체'를 주입하기 때문이다.
  - 이 문제는 bind 메서드를 활용하면 손쉽게 해결 가능하다.
- 다만 이렇게 하면 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 원래의 그것과 달라지는 점은 감안해야 한다.
- bind 메서드로 값을 직접 넘겨준 덕분에 클로저는 발생하지 않게 된 반면 여러 가지 제약사항이 따르게 됐다.

### 이런 변경사항이 발생하지 않게끔 하면서 이슈를 해결하기 위해서 고차함수를 활용할 수 있다.

```javascript
// (3) 콜백 함수를 고차함수로 바꾸는 방법 - 클로저 발생 O
var alertFruitBuilder = function (fruit) {
  return function () {
    alert('your choice is ' + fruit)
  }
}
fruits.forEach(function (fruit) {
  var $li = document.createElement('li')
  $li.innerText = fruit
  $li.addEventListener('click', alertFruitBuilder(fruit))
  $ul.appendChild($li)
})
```

- alertFruitBuilder의 실행 결과로 반환된 함수에는 클로저가 존재한다.
- (궁금증) 근데 그냥 `$li.addEventListener('click', () => alertFruit(fruit))` 이렇게 하면 안 되나? 이거랑 뭔 차이지?
  - 아, 이게 어차피 (1)번 방법이랑 똑같은 거구나. 공통 함수로 쓰려고 콜백 함수를 외부로 꺼내고 싶은 상황에서 고차함수 방법이 나오게 됨.

### 흔히 접근 권한에는 public, private, protected의 세 종류가 있다.

- 정보 은닉은 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈 간의 결합도를 낮추고 유연성을 높이고자 하는 현대 프로그래밍 언어의 중요한 개념 중 하나다.
- 자바스크립트는 기본적으로 변수 자체에 이러한 접근 권한을 직접 부여하도록 설계돼 있지 않다.

### 클로저를 이용하면 함수 차원에서 public한 값과 private한 값을 구분하는 것이 가능하다.

```javascript
var outer = function () {
  var a = 1
  var inner = function () {
    return ++a
  }
  return inner
}
var outer2 = outer()
console.log(outer2())
console.log(outer2())
```

- outer 함수를 종료할 때 inner 함수를 반환함으로써 outer 함수의 지역변수인 a의 값을 외부에서도 읽을 수 있게 됐다.
- 외부에서는 오직 outer 함수가 return한 정보에만 접근할 수 있다.

### 외부에 제공하고자 하는 정보들을 모아서 return하고, 내부에서만 사용할 정보들은 return하지 않는 것으로 접근 권한 제어가 가능한 것이다.

- return한 변수들은 public member가 되고, 그렇지 않은 변수들은 private member가 된다.
- 클로저를 활용해 접근권한을 제어하는 방법은 다음과 같다.

1. 함수에서 지역변수 및 내부함수 들을 생성한다.
2. 외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(대상이 여럿일 때는 객체 또는 배열, 하나일 때는 함수)를 return한다.
