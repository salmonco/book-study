### this는 함수를 호출할 때 결정된다.

- 자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다.
- 실행 컨텍스트는 함수를 호출할 때 생성된다.

### 전역 공간에서 this는 전역 객체를 가리킨다.

- 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문이다.

### 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다.

- 브라우저 환경에서 전역객체는 window이고
- Node.js 환경에서 전역객체는 global이다.

### 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작한다.

```javascript
// 전역변수와 전역객체
var a = 1
console.log(a)        // 1
console.log(window.a) // 1
console.log(this.a)   // 1
```

- 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.
- 궁금증. 전역변수인데 var로 선언하면 전역객체의 프로퍼티에 저장되는 반면 let, const로 선언하면 전역객체의 프로퍼티에 저장되지 않는다. 왜지?
  - var로 선언한 전역 변수는 environmentRecord > 객체 환경 레코드에 연결된 BindingObject를 통해 전역객체의 프로퍼티가 된다. BindingObject는 전역 객체다.
  - let, const로 선언한 전역 변수는 environmentRecord > 선언적 환경 레코드에 등록되어 전역객체의 프로퍼티가 되지 않는다.
 
### var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보인다.

- 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable 속성(변경 및 삭제 가능성)을 false로 정의한다.
- 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는다.
- 이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략이다.

### 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.

- 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작한다.

```javascript
var func = function (x) {
  console.log(this, x)
}
func(1) // Window { ... } 1

var obj = {
  method: func
}
obj.method(2) // { method: f } 2
```

- 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것이다.
- 4번째 줄은 앞에 점이 없으니 함수로서 호출한 것이고, 9번째 줄은 method 앞에 점이 있으니 메서드로서 호출한 것이다. 정말이다(물론 대괄호 표기법에 따른 경우에도 메서드로서 호출한 것이다).

### this에는 호출한 주체에 대한 정보가 담긴다.

- 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체다.
- 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this가 되는 것이다.

### 어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않는다.

- 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라본다.
- 따라서 함수에서의 this는 전역 객체를 가리킨다.
  - 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적한다.

```javascript
// 내부함수에서의 this
var obj1 = {
  outer: function () {
    console.log(this) // (1)
    var innerFunc = function () {
      console.log(this) // (2) (3)
    }
    innerFunc()

    var obj2 = {
      innerMethod: innerFunc
    }
    obj2.innerMethod()
  }
}
```

- 15번째 줄: obj1.outer를 호출한다.
- 2번째 줄: obj1.outer 함수의 실행 컨텍스트가 생성되면서 호이스팅하고, 스코프 체인 정보를 수집하고, this를 바인딩한다. 이 함수는 호출할 때 함수명인 outer 앞에 점(.)이 있었으므로 메서드로서 호출한 것이다. 따라서 this에는 마지막 점 앞의 객체인 obj1이 바인딩된다.
- 7번째 줄: innerFunc를 호출한다.
- 4번째 줄: innerFunc 함수의 실행 컨텍스트가 생성되면서 호이스팅, 스코프 체인 수집, this 바인딩 등을 수행한다. 이 함수를 호출할 때 함수명 앞에는 점(.)이 없었다. 즉 함수로서 호출한 것이므로 this가 지정되지 않았고, 따라서 자동으로 스코프 체인상의 최상위 객체인 전역객체(Window)가 바인딩된다.
- 12번째 줄: obj2.innerMethod를 호출한다.
- 9번째 줄: obj2.innerMethod 함수의 실행 컨텍스트가 생성된다. 이 함수는 호출할 때 함수명인 innerMethod 앞에 점(.)이 있었으므로 메서드로서 호출한 것이다. 따라서 this에는 마지막 점 앞의 객체인 obj2가 바인딩된다.

### 같은 함수임에도 바인딩되는 this의 대상이 달라졌다.

- this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고,
- 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건인 것이다.

### 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠다.

- 변수를 검색하면 우선 가장 가까운 스코프의 LexicalEnvironment를 찾고 없으면 상위 스코프를 탐색하듯이,
- this 역시 현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 말이다.

### ES6에서 this를 바인딩하지 않는 화살표 함수를 새로 도입했다.

- 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다.
- 그 밖에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법이 있다.

### 함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다.

```javascript
setTimeout(function () { console.log(this) }, 300) // (1)

[1, 2, 3, 4, 5].forEach(function (x) { // (2)
  console.log(this, x)
})

document.body.innerHTML += '<button id="a">클릭</button>'
document.body.querySelector('#a')
  .addEventListener('click', function (e) {
    console.log(this, e) // (3)
  })
```

- (1)의 setTimeout 함수와 (2)의 forEach 메서드는 그 내부에서 콜백 함수를 호출할 때 대상이 될 this를 지정하지 않는다. 따라서 콜백 함수 내부에서의 this는 전역객체를 참조한다.
- 한편 (3)의 addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있다. 그러니까 메서드명의 점(.) 앞부분이 곧 this가 되는 것이다.

### 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정한다.

- 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.

### 프로그래밍적으로 '생성자'는 구체적인 인스턴스를 만들기 위한 일종의 틀이다.

- new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다.
- 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다.
- 생성자 함수를 호출(new 명령어와 함께 함수를 호출)하면 우선 생성자의 prototype 프로퍼티를 참조하는 __proto__라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여한다.
