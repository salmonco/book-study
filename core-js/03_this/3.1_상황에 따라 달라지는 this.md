### this는 함수를 호출할 때 결정된다.

- 자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다.
- 실행 컨텍스트는 함수를 호출할 때 생성된다.

### 전역 공간에서 this는 전역 객체를 가리킨다.

- 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문이다.

### 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있다.

- 브라우저 환경에서 전역객체는 window이고
- Node.js 환경에서 전역객체는 global이다.

### 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작한다.

```javascript
// 전역변수와 전역객체
var a = 1
console.log(a)        // 1
console.log(window.a) // 1
console.log(this.a)   // 1
```

- 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.
- 궁금증. 전역변수인데 var로 선언하면 전역객체의 프로퍼티에 저장되는 반면 let, const로 선언하면 전역객체의 프로퍼티에 저장되지 않는다. 왜지?
  - var로 선언한 전역 변수는 environmentRecord > 객체 환경 레코드에 연결된 BindingObject를 통해 전역객체의 프로퍼티가 된다. BindingObject는 전역 객체다.
  - let, const로 선언한 전역 변수는 environmentRecord > 선언적 환경 레코드에 등록되어 전역객체의 프로퍼티가 되지 않는다.
 
### var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보인다.

- 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable 속성(변경 및 삭제 가능성)을 false로 정의한다.
- 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는다.
- 이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략이다.

### 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.

- 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작한다.

```javascript
var func = function (x) {
  console.log(this, x)
}
func(1) // Window { ... } 1

var obj = {
  method: func
}
obj.method(2) // { method: f } 2
```

- 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것이다.
- 4번째 줄은 앞에 점이 없으니 함수로서 호출한 것이고, 9번째 줄은 method 앞에 점이 있으니 메서드로서 호출한 것이다. 정말이다(물론 대괄호 표기법에 따른 경우에도 메서드로서 호출한 것이다).

### this에는 호출한 주체에 대한 정보가 담긴다.

- 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체다.
- 점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this가 되는 것이다.


