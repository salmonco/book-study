**웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺는다.**

예를 들어 웹페이지에 첨부된 이미지들 대부분은 같은 웹 사이트에 있고, 상당수의 하이퍼링크도 같은 사이트를 가리킨다.

**따라서 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지 등을 가져오기 위해서 그 서버에 또 요청하게 될 것이다.**

이 속성을 사이트 지역성(site locality)라 부른다.

따라서 HTTP/1.1(HTTP/1.0의 개선 버전)을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다.

**처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부른다.**

비지속 커넥션은 각 처리가 끝날 때마다 커넥션을 끊지만, 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지한다.

**해당 서버에 이미 맺어져 있는 지속 커넥션을 재사용함으로써, 커넥션을 맺기 위한 준비작업에 따르는 시간을 절약할 수 있다.**

게다가 이미 맺어져 있는 커넥션은 TCP의 느린 시작으로 인한 지연을 피함으로써 더 빠르게 데이터를 전송할 수 있다.

## 1. 지속 커넥션 vs 병렬 커넥션

앞서 봤듯이, 병렬 커넥션은 여러 객체가 있는 페이지를 더 빠르게 전송한다.

하지만 병렬 커넥션에는 다음과 같은 몇 가지 단점이 있다.

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.

지속 커넥션은 병렬 커넥션에 비해 몇 가지 장점이 있다.

**커넥션을 맺기 위한 사전 작업과 지연을 줄여주고, 튜닝된 커넥션을 유지하며, 커넥션의 수를 줄여준다.**

**하지만 지속 커넥션을 잘못 관리할 경우, 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 될 것이다.**

이는 로컬의 리소스 그리고 원격의 클라이언트와 서버의 리소스에 불필요한 소모를 발생시킨다.

**지속 커넥션은 병렬 커넥션과 함께 사용될 때에 가장 효과적이다.**

**오늘날 많은 웹 애플리케이션은 적은 수의 병렬 커넥션만을 맺고 그것을 유지한다.**

두 가지 지속 커넥션 타입이 있는데, HTTP/1.0+에는 'keep-alive' 커넥션이 있고 HTTP/1.1에는 '지속' 커넥션이 있다.

## 2. HTTP/1.0+의 Keep-Alive 커넥션

많은 HTTP/1.0 브라우저와 서버들은 일찍부터 다소 실험적이었던 keep-alive 커넥션이라는 지속 커넥션을 지원하기 위해 확장되었다(1996년 경에 시작됨).

이 초기의 지속 커넥션은 상호 운용과 관련된 설꼐에 문제가 있었지만, 아직 많은 클라이언트와 서버는 이 초기 keep-alive 커넥션을 사용하고 있다.

그리고 그 설계상의 문제는 HTTP/1.1에서 수정되었다.

keep-alive 커넥션의 성능상의 장점은 아래 그림에서 볼 수 있다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/2a1bc1a5-9a1a-451f-bbed-d6c5b8fec88c" />

위 그림에서 같은 네 개의 HTTP 트랜잭션에 대해서, 연속적으로 네 개의 커넥션을 생성하여 처리하는 방식과 하나의 지속 커넥션으로만 처리하는 방식을 비교하였다.

**커넥션을 맺고 끊는 데 필요한 작업이 없어서 시간이 단축되었다.**

또한, TCP 느린 시작이 일어나지 않기 때문에 요청 및 응답 시간이 줄어들었지만, 이 그림에는 표현되어 있지 않다.

## 3. Keep-Alive 동작

keep-alive는 사용하지 않기로 결정되어 HTTP/1.1 명세에서 빠졌다.

하지만 아직도 브라우저와 서버 간에 keep-alive 핸드셰이크가 널리 사용되고 있기 때문에 HTTP 애플리케이션은 그것을 처리할 수 있게 개발해야 한다.

**HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해서 요청에 Connection: Keep-Alive 헤더를 포함시킨다.**

이 요청을 받는 서버는 그다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를 포함시켜 응답한다.

**응답에 Connection: Keep-Alive 헤더가 없으면, 클라이언트는 서버가 keep-alive를 지원하지 않으며, 응답 메시지가 전송되고 나면 서버 커넥션을 끊을 것이라 추정한다.**

<img width="500" alt="" src="https://github.com/user-attachments/assets/03214b40-e3a9-4c45-ae10-6744ea8f8fb8" />

## 4. Keep-Alive 옵션

**Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐이다.**

**클라이언트나 서버가 keep-alive 요청을 받았다고 해서 무조건 그것을 따를 필요는 없다.**

**언제든지 현재의 keep-alive 커넥션을 끊을 수 있으며 keep-alive 커넥션에서 처리되는 트랜잭션의 수를 제한할 수도 있다.**

keep-alive의 동작은 Keep-Alive 헤더의 쉼표로 구분된 옵션들로 제어할 수 있다.

- timeout 파라미터는 Keep-Alive 응답 헤더를 통해 보낸다. 이는 커넥션이 얼마간 유지될 것인지를 의미한다. 하지만 이대로 동작한다는 보장은 없다.
- max 파라미터는 Keep-Alive 응답 헤더를 통해 보낸다. 이는 커넥션이 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지를 의미한다. 하지만 이대로 동작한다는 보장은 없다.
- Keep-Alive 헤더는 진단이나 디버깅을 주목적으로 하는, 처리되지는 않는 임의의 속성들을 지원하기도 한다. 그 문법은 이름[=값] 같은 식이다.

Keep-Alive 헤더 사용은 선택 사항이지만, Connection: Keep-Alive 헤더가 있을 때만 사용할 수 있다.

다음 예는 서버가 약 5개의 추가 트랜잭션이 처리될 동안 커넥션을 유지하거나, 2분 동안 커넥션을 유지하라는 내용의 Keep-Alive 응답 헤더다.

```
Conncection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

## 5. Keep-Alive 커넥션 제한과 규칙

다음은 keep-alive 커넥션에 대한 몇 가지 제한과 사용 방법에 대한 상세 내용이다.

- keep-alive는 HTTP/1.0에서 기본으로 사용되지는 않는다. 클라이언트는 keep-alive 커넥션을 사용하기 위해 Connection: Keep-Alive 요청 헤더를 보내야 한다.

- **커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해 보내야 한다.** 만약 클라이언트가 Connection: Keep-Alive 헤더를 보내지 않으면 서버는 요청을 처리한 후 커넥션을 끊을 것이다.

- 클라이언트는 Connection: Keep-Alive 응답 헤더가 없는 것을 보고 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있다.

- **커넥션이 끊어지기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다.** 이 말은 엔터티 본문이 정확한 Content-Length 값과 함께 멀티파트 미디어 형식(multipart media type)을 가지거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어야 함을 뜻한다. **keep-alive 커넥션에서 잘못된 Content-Length 값을 보내늑 서은 좋지 않은데, 트랜잭션이 끝나는 시점에 기존 메시지의 끝과 새로운 메시지의 시작점을 정확히 알 수 없기 때문이다.**

- 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 한다. **프락시와 게이트웨이는 메시지를 전달하거나 캐시에 넣기 전에 Connection 헤더에 명시된 모든 헤더 필드와 Conneciton 헤더를 제거해야 한다.**

- **정석대로라면, keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와는 맺어지면 안 된다.** 이는 뒤에서 설명할 멍청한(dumb) 프락시로 인해 발생할 문제를 예방하기 위한 것이지만, 현실적으로 그것이 쉽진 않다.

- **기술적으로 HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필드(Connection: Keep-Alive를 포함)는 무시해야 한다.** 오래된 프락시 서버로부터 실수로 전달될 수 있기 때문이다. 실제로, 어떤 클라이언트나 서버는 오래된 프락시에 행(hang)이 걸릴 수 있는 위험이 있음에도 이 규칙을 지키지 않기도 한다.

- 클라이언트는, 응답 전체를 모두 받기 전에 커넥션이 끊어졌을 경우, 별다른 문제가 없으면 요청을 다시 보낼 수 있게 준비되어 있어야 한다. 그렇지 않으면 요청이 반복될 경우 문제가 발생할 수 있다.

## 6. Keep-Alive와 멍청한(dumb) 프락시

웹 클라이언트의 요청에 Connection: Keep-Alive 헤더가 있으면, 클라이언트가 현재 연결하고 있는 TCP 커넥션을 끊지 않고 계쏙 유지하려는 것이다.

헤더 이름이 'conneciton'인 것도 이 때문이다.

클라이언트가 웹 서버에 요청을 보내려는 중이라면, 그 요청으로 생긴 커넥션이 keep-alive가 되기를 원한다는 의미로 Connection: Keep-Alive 헤더를 전송한다.

서버가 keep-alive를 지원한다면 Connection: Keep-Alive를 응답에 포함할 것이고, 지원하지 않으면 포함하지 않을 것이다.

### Connection 헤더의 무조건 전달

**특히 문제는 프락시에서 시작되는데, 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다.**

오래되고 단순한 수많은 프락시들이 Connection 헤더에 대한 처리 없이 요청을 그대로 전달한다.

웹 클라이언트가 무조건 전달을 하는 멍청한 프락시를 거쳐 웹 서버에 메시지를 전송한다고 생각해보자.

그 상황은 아래 그림에서 볼 수 있다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/d90a3b8f-01d2-4aa1-9438-a3ef153b0775" />

위 그림에서 일어나는 일은 다음과 같다.

1. 웹 클라이언트는 프락시에 Connection: Keep-Alive 헤더와 함께 메시지를 보내고, 커넥션을 유지하기를 요청한다. 클라이언트는 커넥션을 유지하자는 요청이 받아들여졌는지 확인하기 위해 응답을 기다린다.

2. **멍청한 프락시는 요청받은 HTTP의 Connection 헤더(단순히 확장 헤더로만 취급된다)를 이해하지 못한다.** 프락시는 keep-alive가 무엇인지 모르기 때문에, 다음 서버에 메시지를 그대로 전달한다. 하지만 Connection 헤더는 홉별(hop-by-hop) 헤더다(이는 오직 한 개의 전송 링크에만 적용되며 다음 서버로 전달되어서는 안 된다). 여기서부터 문제가 시작된다.

3. **전달된 HTTP 요청이 서버에 도착한다. 웹 서버가 프락시로부터 Connection: Keep-Alive 헤더를 받으면, 웹 서버는 프락시(기존에 클라이언트로부터 받았을 때와 같이)가 커넥션을 유지하자고 요청하는 것으로 잘못 판단하게 된다.** 웹 서버는 문제될 게 없기 때문에, 프락시와 커넥션을 유지하는 것에 동의를 하고 Connection: Keep-Alive 헤더를 포함하여 응답한다. 웹 서버는 프락시와 keep-alive 커넥션이 맺어져 있는 상태로 keep-alive 규칙에 맞게 통신을 하는 것으로 판단한다. 하지만 프락시는 keep-alive를 전혀 이해하지 못한다.

4. 멍청한(dumb) 프락시는 서버로부터 받은 Connection: Keep-Alive 헤더를 포함하고 있는 응답 메시지를 클라이언트에게 전달한다. 클라이언트는 이 헤더를 통해 프락시가 커넥션을 유지하는 것에 동의했다고 추정한다. **이 시점에 클라이언트와 서버는 커넥션을 유지하고 있다고 생각하지만, 정작 프락시는 keep-alive를 전혀 이해하지 못한다.**

5. **프락시는 keep-alive를 전혀 모르지만, 받았던 모든 데이터를 그대로 클라이언트에게 전달하고 나서 서버가 커넥션을 끊기를 기다린다.** 하지만 서버는 프락시가 자신에게 커넥션을 유지하기를 요청한 것으로 알고 있기 때문에 커넥션을 끊지 않는다. **따라서 프락시는 커넥션이 끊어지기 전까지는 계속 커넥션이 끊어지기를 기다리게 된다.**

6. **클라이언트가 응답 메시지를 받으면, 다음 요청을 보내기 시작하는데, 커넥션이 유지되고 있는 프락시에 그 요청을 보낸다. 프락시는 같은 커넥션상에서 다른 요청이 오는 경우는 예쌍하지 못하기 때문에, 그 요청은 프락시로부터 무시되고 브라우저는 아무런 응답 없이 로드 중이라는 표시만 나온다.**

7. 이런 잘못된 통신 때문에, 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다린다.

### 프락시와 홉별 헤더

**이런 종류의 잘못된 통신을 피하려면, 프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안 된다.**

**따라서 프락시가 Connection: Keep-Alive 헤더를 받으면 Conneciton 헤더뿐만 아니라 Keep-Alive란 이름의 헤더도 전달하면 안 된다.**

또한, Connection 헤더의 값으로 명시되지 않는, Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade와 같은 홉별 헤더들 역시 전달하거나 캐시하면 안 된다.

## 7. Proxy-Connection 살펴보기

넷스케이프의 브라우저 및 프락시 개발자들은 모든 웹 애플리케이션이 HTTP 최신 버전을 지원하지 않아도, 모든 헤더를 무조건 전달하는 문제를 해결할 수 있는 기발한 차선책을 제시하였다.

**그 차선책은, 클라이언트의 요청이 중개서버를 통해 이어지는 경우 모든 헤더를 무조건 전달하는 문제를 해결하기 위해 Proxy-Connection이라는 헤더를 사용하는 것이다(하지만 모든 상황에서 동작하지는 않는다).**

Proxy-Connection은 프락시를 별도로 설정할 수 있는 현대의 브라우저들에서 지원하고 있으며, 많은 프락시들도 이것을 인식한다.

**멍청한 프락시는 Connection: Keep-Alive 같은 홉별 헤더를 무조건 전달하기 때문에 문제를 일으킨다.**

**홉별 헤더들은 한 개의 특정 커넥션에서 쓰이고 그 이후에는 전달하면 안 된다.**

홉별 헤더를 전달받은 서버가 그 헤더를 자신과 프락시 간의 커넥션에 대한 것으로 오해하면서 문제가 생기는 것이다.

넷스케이프는 멍청한 프락시 문제를 해결하기 위해 브라우저에서 일반적으로 전달하는 Conneciton 헤더 대신에 비표준인 Proxy-Connetion 확장 헤더를 프락시에게 전달한다.

**프락시가 Proxy-Connetion 헤더를 무조건 전달하더라고 웹 서버는 그것을 무시하기 때문에 별문제가 되지 않는다.**

하지만 영리한 프락시(지속 커넥션 핸드셰이킹을 이해할 수 있는)라면, 의미 없는 Proxy-Connetion 헤더를 Connection 헤더로 바꿈으로써 원하던 효과를 얻게 될 것이다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/81ce4fa4-47e7-43b9-a22e-87a308ff5ac7" />

그림의 a~b는 무조건 전달로 인해 Proxy-Connection 헤더가 웹 서버에 전달되더라도 아무런 문제가 생기지 않는다는 것을 보여준다.

Proxy-Connection 헤더가 웹 서버에 전달되더라도 클라이언트와 프락시 사이 혹은 프락시와 서버 사이에 keep-alive 커넥션이 맺어지지 않는다.

그림의 e~h에서 영리한 프락시는 Proxy-Connection 헤더가 keep-alive를 요청하는 것임을 인식하여, keep-alive 커넥션을 맺기 위해 자체적으로 Connection: Keep-Alive 헤더를 웹 서버에 전송한다.

이 방식은 클라이언트와 서버 사이에 한 개의 프락시만 있는 경우에서만 동작한다.

**하지만 멍청한 프락시의 양옆에 영리한 프락시가 있다면 그림에서와 같이 잘못된 헤더를 만들어내는 문제가 다시 발생한다.**

<img width="500" alt="" src="https://github.com/user-attachments/assets/9484948c-2cfd-4c0b-8bd4-865e0d95c511" />

게다가 문제를 발생시키는 프락시들은 방화벽, 캐시 서버, 혹은 리버스 프락시 서버 가속기와 같이 네트워크상에서 '보이지 않는' 경우가 많다.

브라우저는 이러한 기기들을 볼 수 없으므로 Proxy-Connection 헤더를 보내지 못한다.

보이지 않는 웹 애플리케이션들이 지속 커넥션을 명확히 구현하는 것은 중요하다.

## 8. HTTP/1.1의 지속 커넥션

**HTTP/1.1에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원한다.**

지속 커넥션의 목적은 keep-alive 커넥션과 같지만 그에 비해 더 잘 동작한다.

**HTTP/1.0의 keep-alive 커넥션과는 달리 HTTP/1.1의 지속 커넥션은 기본으로 활성화되어 있다.**

HTTP/1.1에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급한다.

**HTTP/1.1 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection: close 헤더를 명시해야 한다.**

이는 keep-alive 커넥션이 선택 사항이 아닐 뿐만 아니라 지원 자체를 하지 않다는 점에서 이전 HTTP 프로토콜과는 크게 다르다.

**HTTP/1.1 클라이언트는 응답에 Connection: close 헤더가 없으면 응답 후에도 HTTP/1.1 커넥션을 계속 유지하자는 것으로 추정한다.**

하지만 클라이언트와 서버는 언제든지 커넥션을 끊을 수 있다.

Conneciton: close를 보내지 않는 것이 서버가 커넥션을 영원히 유지하겠다는 것을 뜻하지는 않는다.

## 9. 지속 커넥션의 제한과 규칙

다음은 지속 커넥션에 대한 몇 가지 제한과 사용 방법에 대한 상세 내용이다.

- 클라이언트가 요청에 Conneciton: close 헤더를 포함해 보냈으면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없다.

- 클라이언트가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 Connection: close 헤더를 보내야 한다.

- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커넥션을 지속시킬 수 있다. 예를 들어 엔터티 본문은 정확한 Content-Length 값을 가지거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어 있어야 한다.

- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 한다.

- **HTTP/1.1 프락시 서버는 클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않는 한 지속 커넥션을 맺으면 안 된다.** 앞서 설명했듯이 오래된 프락시가 Connection 헤더를 전달하는 문제가 발생할 수 있기 때문이다. 현실적으로 이것이 쉽지는 않으며, 많은 벤더가 이 규칙을 지키지 않는다.

- 서버는 메시지를 전송하는 중간에 커넥션을 끊지 않을 것이고 커넥션을 끊기 전에 적어도 한 개의 요청에 대해 응답을 할 것이긴 하지만, HTTP/1.1 기기는 Connection 헤더의 값과는 상관없이 언제든지 커넥션을 끊을 수 있다.

- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야만 한다. 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 한 다시 보내야 한다.

- 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면, 요청을 반복해서 보내도 문제가 없는 경우에는 요청을 다시 보낼 준비가 되어 있어야 한다.

- **하나의 사용자 클라이언트는 서버의 과부하를 방지하기 위해서, 넉넉잡아 두 개의 지속 커넥션만을 유지해야 한다.** 따라서 N명의 사용자가 서버로 접근하려 한다면, 프락시는 서버나 상위 프락시에 넉넉잡아 약 2N개의 커넥션을 유지해야 한다.
