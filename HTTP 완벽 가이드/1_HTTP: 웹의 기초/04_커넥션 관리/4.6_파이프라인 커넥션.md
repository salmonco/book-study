**HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝할 수 있다.**

이는 keep-alive 커넥션의 성능을 더 높여준다.

**여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓인다.**

첫 번째 요청이 네트워크를 통해 지구 반대편에 있는 서버로 전달되면, 거기에 이어 두 번째와 세 번째 요청이 전달될 수 있다.

이는 대기 시간이 긴 네트워크 상황에서 네트워크상의 왕복으로 인한 시간을 줄여서 성능을 높여준다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/80a1b885-7233-4848-b506-146fd73199ac" />

위 그림의 a에서 c는 지속 커넥션이 어떻게 TCP 커넥션 지연을 제거하며, 파이프라인을 통한 요청이 어떻게 전송 대기 시간을 단축시키는지 보여준다.

파이프라인에는 여러 가지 제약 사항이 있다.

- HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안 된다.

- HTTP 응답은 요청 순서와 같게 와야 한다. HTTP 메시지는 순번이 매겨져 있지 않아서 응답이 순서 없이 오면 순서에 맞게 정렬시킬 방법이 없다.

- **HTTP 클라이언트는 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어 있어야 한다.** 클라이언트가 지속 커넥션을 맺고 나서 바로 10개의 요청을 보낸다고 하더라도 서버는 5개의 요청만 처리하고 커넥션을 임의로 끊을 수 있다. 남은 5개의 요청은 실패할 것이고 클라이언트는 예상치 못하게 끊긴 커넥션을 다시 맺고 요청을 보낼 수 있어야 한다.

- **HTTP 클라이언트는 POST 요청같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안 된다.** 에러가 발생하면 파이프라인을 통한 요청 중에 어떤 것들이 서버에서 처리되었는지 클라이언트가 알 방법이 없다. POST와 같은 비멱등(nonidempotent) 요청을 재차 보내면 문제가 생길 수 있기 때문에, 문제가 있는 상황에서 그런 위험한 메서드로 요청을 보내서는 안 된다.
