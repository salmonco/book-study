커넥션 관리(특히 언제 커넥션을 끊는가)에는 명확한 기준이 없다.

이 이슈는 수많은 개발자가 알고 있는 것보다 더 미묘하며, 그에 관한 기술 문서도 별로 없다.

## 1. '마음대로' 커넥션 끊기

어떠한 HTTP 클라이언트, 서버, 혹은 프락시든 언제든지 TCP 전송 커넥션을 끊을 수 있다.

보통 커넥션은 메시지를 다 보낸 다음 끊지만, 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있다.

이 상황은 파이프라인 지속 커넥션에서와 같다.

**HTTP 애플리케이션은 언제든지 지속 커넥션을 임의로 끊을 수 있다.**

예를 들어, 지속 커넥션이 일정 시간 동안 요청을 전송하지 않고 유휴 상태에 있으면 서버는 그 커넥션을 끊을 수 있다.

**하지만 서버가 그 유휴상태에 있는 커넥션을 끊는 시점에, 서버는 클라이언트가 데이터를 전송하지 않을 것이라고 확신하지 못한다.**

만약 이 일이 벌어지면 클라이언트는 그 요청 메시지를 보내는 도중에 문제가 생긴다.

## 2. Content-Length와 Truncation

**각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다.**

일부 오래된 HTTP 서버는 자신이 커넥션을 끊으면 데이터 전송이 끝났음을 의미하는 형태로 개발되어 있기 때문에, Content-Length 헤더를 생략하거나 잘못된 길이 정보로 응답하는 경우도 있다.

**클라이언트나 프락시가 커넥션이 끊어졌다는 HTTP 응답을 받은 후, 실제 전달된 엔터티의 길이와 Content-Length의 값이 일치하지 않거나 Content-Length 자체가 존재하지 않으면 수신자는 데이터의 정확한 길이를 서버에게 물어봐야 한다.**

만약 수신자가 캐시 프락시일 경우 응답(잠재적인 에러가 복합적으로 발생하는 것을 최소화하기 위해)을 캐시하면 안 된다.

프락시는 Content-Length를 정정하려 하지 말고 메시지를 받은 그대로 전달해야 한다.

## 3. 커넥션 끊기의 허용, 재시도, 멱등성

커넥션은 심지어 에러가 없더라도 언제든 끊을 수 있다.

HTTP 애플리케이션은 예상치 못하게 커넥션이 끊어졌을 때에 적절히 대응할 수 있는 준비가 되어 있어야 한다.

**클라이언트가 트랜잭션을 수행 중에 전송 커넥션이 끊기게 되면, 클라이언트는 그 트랜잭션을 재시도 하더라도 문제가 없다면 커넥션을 다시 맺고 한 번 더 전송을 시도해야 한다.**

그 상황은 파이프라인 커넥션에서 좀 더 어려워진다.

클라이언트는 여러 요청을 큐에 쌓아 놓을 수 있지만, 서버는 아직 처리되지 않고 스케줄이 조정되어야 하는 요청들을 남겨둔 채로 커넥션을 끊어버릴 수도 있다.

그로 인한 부작용들을 조심해야 한다.

어떤 요청 데이터가 전송되었지만, 응답이 오기 전에 커넥션이 끊기면 클라이너트는 실제로 서버에서 얼마만큼 요청이 처리되었는지 전혀 알 수 없다.

정적인 HTML 페이지를 GET 하는 부류의 요청들은 반복적으로 요청하더라도 결과적으로 아무런 영향을 끼치지 않는다.

반면 온라인 서점에 주문을 POST 하는 부류의 요청들은 반복될 경우 주문이 여러 번 중복될 것이기 때문에 반복은 피해야 한다.

한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(idempotent)하다고 한다.

GET, HEAD, PUT, DELETE, TRACE 그리고 OPTIONS 메서드들은 멱등하다고 이해하면 된다.

**클라이언트는 POST와 같이 멱등이 아닌 요청은 파이프라인을 통해 요청하면 안 된다.**

그렇지 않으면 전송 커넥션이 예상치 못하게 끊어져 버렸을 때, 알 수 없는 결과를 초래할 수 있다.

비멱등인 요청을 다시 보내야 한다면, 이전 요청에 대한 응답을 받을 때까지 기다려야 한다.

비멱등인 메서드나 순서에 대해 에이전트가 요청을 다시 보낼 수 있도록 기능을 제공한다 하더라도, 자동으로 재시도하면 안 된다.

예를 들어 대부분 브라우저는 캐시된 POST 요청 페이지를 다시 로드하려고 할 때, 요청을 다시 보내기를 원하는지 묻는 대화상자를 보여준다.

## 4. 우아한 커넥션 끊기

**TCP 커넥션은 아래 그림에서 보듯이 양방향이다.**

<img width="500" alt="" src="https://github.com/user-attachments/assets/d4ec058f-3df2-4bca-815f-9cd8ff4477f2" />

**TCP 커넥션의 양쪽에는 데이터를 읽거나 쓰기 위한 입력 큐와 출력 큐가 있다.**

한쪽 출력 큐에 있는 데이터는 다른 쪽의 입력 큐에 보내질 것이다.

### 전체 끊기와 절반 끊기

**애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있다.**

close()를 호출하면 TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는다.

이를 '전체 끊기'라고 하며 아래 그림에서 볼 수 있다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/3515d48e-4166-47cd-bb93-ea07d224b179" />

입력 채널이나 출력 채널 중에 하나를 개별적으로 끊으려면 shutdown()을 호출하면 된다.

이를 '절반 끊기'라고 부르며 위 그림 b와 c에서 볼 수 있다.

### TCP 끊기와 리셋 에러

단순한 HTTP 애플리케이션은 전체 끊기만을 사용할 수 있다.

**하지만 애플리케이션이 각기 다른 HTTP 클라이언트, 서버, 프락시와 통신할 때, 그리고 그들과 파이프라인 지속 커넥션을 사용할 때, 기기들에 예상치 못한 쓰기 에러를 발생하는 것을 예방하기 위해 '절반 끊기'를 사용해야 한다.**

**보통은 커넥션의 출력 채널을 끊는 것이 안전하다.**

커넥션의 반대편에 있는 기기는 모든 데이터를 버퍼로부터 읽고 나서 데이터 전송이 끝남과 동시에 당신이 커넥션을 끊었다는 것을 알게 될 것이다.

**클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션의 입력 채널을 끊는 것은 위험하다.**

만약 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면, 아래 그림과 같이 서버의 운영체제는 TCP 'connection reset by peer' 메시지를 클라이언트에 보낼 것이다.

<img width="500" alt="" src="https://github.com/user-attachments/assets/9544e0b9-ad5b-4bec-a99d-abf7868feeec" />

대부분 운영체제는 이것을 심각한 에러로 취급하여 버퍼에 저장된, 아직 읽히지 않은 데이터를 모두 삭제한다.

이러한 상황은 파이프라인 커넥션에서는 더 악화된다.

10개 요청을 파이프라인 지속 커넥션을 통해 전송하였고, 이미 응답은 운영체제의 버퍼에 있지만 아직은 애플리케이션이 읽지는 않았다고 해보자.

그러고 나서 당신은 11번째 요청을 보냈지만, 서버는 이 커넥션을 충분히 오래 유지되었다고 판단하고 연결을 끊어버렸다고 해보자.

11번째 요청을 이미 종료된 커넥션에 보냈기 때문에, 서버는 요청을 처리하지 않고 'connection reset by peer' 메시지로 응답한다.

이 리셋 메시지는 입력 버퍼에 있는 데이터를 지운다.

결론적으로 데이터를 읽으려 하면, connection reset by peer 에러를 받게 될 것이고, 응답 데이터가 당신의 기기에 잘 도착하였어도 아직 읽히지 않은 버퍼에 있는 응답 데이터는 사라지게 된다.

### 우아하게 커넥션 끊기

HTTP 명세에서는 클라이언트나 서버가 예기치 않게 커넥션을 끊어야 한다면, "우아하게 커넥션을 끊어야 한다"라고 하지만, 정작 그 방법은 설명하지 않고 있다.

**일반적으로 애플리케이션이 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다.**

**양쪽에서 더는 데이터를 전송하지 않을 것이라고 알려주면(예를 들어 출력 채널의 커넥션을 끊는 것), 커넥션은 리셋의 위험 없이 온전히 종료된다.**

안타깝게도 상대방이 절반 끊기를 구현했다는 보장도 없고 절반 끊기를 했는지 검사해준다는 보장도 없다.

따라서 커넥션을 우아하게 끊고자 하는 애플리케이션은 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 대해 상태 검사를 주기적으로 해야 한다.

만약 입력 채널이 특정 타임아웃 시간 내에 끊어지지 않으면, 애플리케이션은 리소스를 보호하기 위해 커넥션을 강제로 끊을 수도 있다.
