타입 확장은 기존 타입을 사용해서 새로운 타입을 정의하는 것을 말한다.

기본적으로 타입스크립트에서는 interface와 type 키워드를 사용해서 타입을 정의하고 extends, 교차 타입, 유니온 타입을 사용하여 타입을 확장한다.

## 1. 타입 확장의 장점

타입 확장의 가장 큰 장점은 코드 중복을 줄일 수 있다는 것이다.

중복되는 타입을 반복적으로 선언하는 것보다 기존에 작성한 타입을 바탕으로 타입 확장을 함으로써 불필요한 코드 중복을 줄일 수 있다.

타입 확장은 중복 제거, 명시적인 코드 작성 외에도 확장성이란 장점을 가지고 있다.

## 2. 유니온 타입

합집합의 개념과 비슷하다.

```typescript
type MyUnion = A | B
```

**유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근할 수 있다.**

```typescript
interface CookingStep {
  orderId: string;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep) {
  return step.distance;
  // Error: Property 'distance' does not exist on type 'CookingStep | DeliveryStep'.
  // Error: Property 'distance' does not exist on type 'CookingStep'.
}
```

인자로 받는 step의 타입이 CookingStep이라면 distance 속성을 찾을 수 없기 때문에 에러가 발생한다.

타입스크립트의 타입을 속성의 집합이 아니라 값의 집합이라고 생각해야 유니온 타입이 합집합이라는 개념을 이해할 수 있다.

## 3. 교차 타입

교집합의 개념과 비슷하다.

```typescript
interface CookingStep {
  orderId: string;
  time: number;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

type BaedalProgress = CookingStep & DeliveryStep
```

여기서 유니온 타입과 다른 점이 있다.

**BaedalProgress는 CookingStep과 DeliveryStep 타입을 합쳐 모든 속성을 가진 단일 타입이 된다.**

```typescript
function logBaedalInfo(progress: BaedalProgress) {
  console.log(`주문 금액: ${progress.price}`);
  console.log(`배달 거리: ${progress.distance}`);
}
```

BaedalProgress 타입의 progress 값은 CookingStep이 갖고 있는 price 속성과 DeliveryStep이 갖고 있는 distance 속성을 포함하고 있다.

다시 말하지만 타입스크립트의 타입을 속성의 집합이 아니라 값의 집합으로 이해해야 한다.

BaedalProgress 교차 타입은 CookingStep이 가진 속성(orderId, time, price)과 DeliveryStep이 가진 속성(orderId, time, distance)을 모두 만족(교집합)하는 값의 타입(집합)이라고 해석할 수 있다.

## 4. extends와 교차 타입

extends 키워드를 사용해서 교차 타입을 작성할 수도 있다.

```typescript
interface BaseMenuItem {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}

interface BaseCartItem extends BaseMenuItem {
  quantity: number;
}
```

BaseCartItem은 BaseMenuItem을 확장함으로써 BaseMenuItem의 속성을 모두 포함하고 있다.

이를 교차 타입의 관점에서 작성하면 다음과 같다.

```typescript
type BaseMenuItem = {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}

type BaseCartItem = {
  quantity: number;
} & BaseMenuItem

const baseCartItem: BaseCartItem = {
  itemName: '지은이네 떡볶이',
  itemImageUrl: 'https://~~',
  itemDiscountAmount: 2000,
  stock: 100,
  quantity: 2,
}
```

BaseCartItem은 quantity라는 새로운 속성과 BaseMenuItem의 모든 속성을 가진 단일 타입이다.

교차 타입을 사용한 코드에서는 BaseMenuItem과 BaseCartItem을 interface가 아닌 type으로 선언했다.

왜냐하면 유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type 키워드로만 선언할 수 있기 때문이다.

주의할 점은 extends 키워드를 사용한 타입이 교차 타입과 100% 상응하지는 않는다는 것이다.

```typescript
interface DeliveryTip {
  tip: number;
}

interface Filter extends DeliveryTip {
  tip: string;
  // Error: Interface 'Filter' incorrectly extends interface 'DeliveryTip'.
  // Error: Types of property 'tip' are incompatible.
  // Error: Type 'string' is not assignable to type 'number'.
}
```

DeliveryTip 타입은 number 타입의 tip 속성을 가지고 있다.

이때 DeliveryTip을 extends로 확장한 Filter 타입에 string 타입의 속성 tip을 선언하면 tip의 타입이 호환되지 않는다는 에러가 발생한다.

같은 예시를 교차 타입으로 작성해보자.

```typescript
type DeliveryTip = {
  tip: number;
}

type Filter = DeliveryTip & {
  tip: string;
}
```

extends를 &로 바꿨을 뿐인데 에러가 발생하지 않는다.

이때 tip 속성의 타입은 number일까? string일까? 정답은 never다.

type 키워드는 교차 타입으로 선언되었을 때 새롭게 추가되는 속성에 대해 미리 알 수 없기 때문에 선언 시 에러가 발생하지 않는다.

하지만 tip이라는 같은 속성에 대해 서로 호환되지 않는 타입이 선언되어 결국 never 타입이 된 것이다.

## 5. 배달의민족 메뉴 시스템에 타입 확장 적용하기

```typescript
/**
 * 메뉴에 대한 타입
 * 메뉴 이름과 메뉴 이미지에 대한 정보를 담고 있다
 */
interface Menu {
  name: string;
  image: string;
}
```

Menu 인터페이스를 기반으로 사용자에게 메뉴 목록을 보여줄 수 있을 것이다.

```typescript
function MainMenu() {
  // Menu 타입을 원소로 갖는 배열
  const menuList: Menu[] = [{ name: '1인분', image: '1인분.png' }, ...]

  return (
    <ul>
      {menuList.map((menu) => (
        <li>
          <img src={menu.image} />
          <span>{menu.name}</span>
        </li>
      ))}
    </ul>
  )
}
```

이때 특정 메뉴의 중요도를 다르게 주기 위한 요구 사항이 추가되었다고 가정해보자.

> 1. 특정 메뉴를 길게 누르면 gif 파일이 재생되어야 한다.
> 2. 특정 메뉴는 이미지 대신 별도의 텍스트만 노출되어야 한다.

요구 사항을 만족하는 타입의 작성 방법을 2가지로 생각해볼 수 있다.

```typescript
/**
 * 방법1 타입 내에서 속성 추가
 * 기존 Menu 인터페이스에 추가된 정보를 전부 추가
 */
interface Menu {
  name: string;
  image: string;
  gif?: string; // 요구 사항 1. 특정 메뉴를 길게 누르면 gif 파일이 재생되어야 한다
  text?: string; // 요구 사항 2. 특정 메뉴는 이미지 대신 별도의 텍스트만 노출되어야 한다
}

/**
 * 방법2 타입 확장 활용
 * 기존 Menu 인터페이스는 유지한 채, 각 요구 사항에 따른 별도 타입을 만들어 확장시키는 구조
 */
interface Menu {
  name: string;
  image: string;
}

/**
 * gif를 활용한 메뉴 타입
 * Menu 인터페이스를 확장해서 반드시 gif 값을 갖도록 만든 타입
 */
interface SpecialMenu extends Menu {
  gif: string; // 요구 사항 1. 특정 메뉴를 길게 누르면 gif 파일이 재생되어야 한다
}

/**
 * 별도의 텍스트를 활용한 메뉴 타입
 * Menu 인터페이스를 확장해서 반드시 text 값을 갖도록 만든 타입
 */
interface PackageMenu extends Menu {
  text: string; // 요구 사항 2. 특정 메뉴는 이미지 대신 별도의 텍스트만 노출되어야 한다
}
```

다음처럼 3가지 종류의 메뉴 목록이 있을 때 각 방법을 적용해보자.

```typescript
/**
 * 각 배열은 서버에서 받아온 응답 값이라고 가정
 */
const menuList = [
  { name: '찜', image: '찜.png' },
  { name: '찌개', image: '찌개.png' },
  { name: '회', image: '회.png' },
]

const specialMenuList = [
  { name: '돈까스', image: '돈까스.png', gif: '돈까스.gif' },
  { name: '피자', image: '피자.png', gif: '피자.gif' },
]

const packageMenuList = [
  { name: '1인분', image: '1인분.png', text: '1인 가구 맞춤형' },
  { name: '족발', image: '족발.png', text: '오늘은 족발로 결정' },
]
```

### [방법 1] 하나의 타입에 여러 속성을 추가할 때

각 메뉴 목록은 Menu[]로 표현할 수 있다.

```typescript
menuList: Menu[] // OK
specialMenuList: Menu[] // OK
packageMenuList: Menu[] // OK
```

specialMenuList 배열의 원소가 각 속성에 접근한다고 했을 때 다음과 같은 문제가 발생할 수 있다.

```typescript
specialMenuList.map((menu) => menu.text) // TypeError: Cannot read properties of undefined
```

specialMenuList는 Menu 타입의 원소를 갖기 때문에 text 속성에도 접근할 수 있다.

하지만 specialMenuList 배열의 모든 원소는 text라는 속성을 가지고 있지 않으므로 에러가 발생한다.

### [방법 2] 타입을 확장하는 방식

각 배열의 타입을 확장할 타입에 맞게 명확히 규정할 수 있다.

```typescript
menuList: Menu[] // OK

specialMenuList: Menu[] // NOT OK
specialMenuList: SpecialMenu[] // OK

packageMenuList: Menu[] // NOT OK
packageMenuList: PackageMenu[] // OK
```

이를 바탕으로 specialMenuList 배열의 원소 내 속성에 동일하게 접근한다고 가정하면 프로그램을 실행하지 않고도 타입이 잘못되었음을 미리 알 수 있다.

```typescript
specialMenuList.map((menu) => menu.text) // Property 'text' does not exist on type 'SpecialMenu'
```

**결과적으로 주어진 타입에 무분별하게 속성을 추가하여 사용하는 것보다 타입을 확장해서 사용하는 것이 좋다.**

적절한 네이밍을 사용해서 타입의 의도를 명확히 표현할 수도 있고, 코드 작성 단계에서 예기치 못한 버그도 예방할 수 있기 때문이다.
