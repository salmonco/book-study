타입스크립트는 리액트 프로젝트에서 공통 컴포넌트에 어떤 타입의 속성(프로퍼티)이 제공되어야 하는지 알려준다.

더불어 필수로 전달되어야 하는 속성이 전달되지 않았을 때는 에러를 표시하여 유지보수 과정에서 발생할 수 있는 다양한 실수를 사전에 막을 수 있게 해준다.

이 절에서는 타입스크립트로 Select 컴포넌트를 구현해보면서 타입스크립트의 장점을 알아보자.

## 1. JSX로 구현된 Select 컴포넌트

아래는 JSX로 구현된 Select 컴포넌트이다.

이 컴포넌트는 각 option의 키(key)-값(value) 쌍을 객체를 받고 있으며, 선택된 값이 변경될 때 호출되는 onChange 이벤트 핸들러를 받도록 구현되어 있다.

그러나 추가적인 설명이 없다면 컴포넌트를 사용하는 입장에서 각 속성에 어떤 타입의 값을 전달해야 할지 알기 어렵다.

```typescript
const Select = ({ onChange, options, selectedOption }) => {
  const handleChange = (e) => {
    const selected = Object.entries(options)
      .find(([_, value]) => value === e.target.value)?.[0]
    onChange?.(selected)
  }

  return (
    <select
      onChange={handleChange}
      value={selectedOption && options[selectedOption]}
    >
      {Object.entries(options).map(([key, value]) => (
        <option key={key} value={value}>
          {value}
        </option>
      ))}
    </select>
  )
}
```

따라서 컴포넌트를 사용하는 개발자가 각 속성에 어떤 타입의 값을 전달해야 할지 명확히 알 수 있도록 추가적인 설명이 필요하다.

## 2. JSDocs로 일부 타입 지정하기

컴포넌트의 속성 타입을 명시하기 위해 JSDocs를 사용할 수 있다.

JSDocs를 활용하면 컴포넌트에 대한 설명과 각 속성이 어떤 역할을 하는지 간단하게 알려줄 수 있다.

```typescript
/**
 * Select 컴포넌트
 * @param {Object} props - Select 컴포넌트로 넘겨주는 속성
 * @param {Object} props.options - { [key: string]: string } 형식으로 이루어진 option 객체
 * @param {string | undefined} props.selectedOption - 현재 선택된 option의 key값 (optional)
 * @param {function} props.onChange - select 값이 변경되었을 때 불리는 callBack 함수 (optional)
 * @returns {JSX.Element}
 */
const Select = // ...
```

## 3. props 인터페이스 적용하기

**JSDocs를 활용하면 각 속성의 대략적인 타입과 어떤 역할을 하는지 파악할 수 있지만, options가 어떤 형식의 객체를 나타내는지나 onChange의 매개변수 및 반환 값에 대한 구체적인 정보를 알기 쉽지 않아서 잘못된 타입이 전달될 수 있는 위험이 있다.**

**이러한 문제를 해결하기 위해 타입스크립트를 사용하여 좀 더 정교하고 구체적인 타입을 지정할 수 있다.**

먼저 JSX 파일의 확장자를 TSX로 변경한 후에 Select 컴포넌트의 props에 대한 인터페이스를 작성해보자.

```typescript
type Option = Record<string, string> // { [key: string]: string }

interface SelectProps {
  options: Option;
  selectedOption?: string;
  onChange?: (selected?: string) => void;
}

const Select = ({ options, selectedOption, onChange }: SelectProps): JSX.Element => // ...
```

예시에서는 먼저 Option이라는 타입을 정의하고, SelectProps에서 이 타입을 재사용하고 있다.

Record는 키(key)와 값(value)의 타입이 모두 string인 객체 타입을 생성하는 유틸리티 타입으로 사용된다.

options의 타입을 정의해줌으로써 string이 아닌 배열이나 다른 유형의 value를 가진 객체는 전달할 수 없게 되었다.

onChange는 선택된 string 값(또는 undefined)을 매개변수로 받고 어떤 값도 반환하지 않는(void) 함수임을 명확하게 표현하고 있다.

또한 onChange는 옵셔널 프로퍼티(선택적 속성)이기 때문에 부모 컴포넌트에서 넘겨주지 않아도 해당 컴포넌트를 사용할 수 있다.

## 4. 리액트 이벤트

리액트는 가상 DOM을 다루면서 이벤트도 별도로 관리한다.

**onclick, onchange같이 DOM 엘리먼트에 등록되어 처리하는 이벤트 리스너와 달리, 리액트 컴포넌트(노드)에 등록되는 이벤트 리스너는 onClick, onChange처럼 카멜 케이스로 표기한다.**

따라서 리액트 이벤트는 브라우저의 고유한 이벤트와 완전히 동일하게 동작하지는 않는다.

예를 들어 리액트 이벤트 핸들러는 이벤트 버블링 단계에서 호출된다.

이벤트 캡처 단계에서 이벤트 핸들러를 등록하기 위해서는 onClickCapture, onChangeCapture와 같이 일반 이벤트 리스너 이름 뒤에 Capture를 붙여야 한다.

또한 리액트는 브라우저 이벤트를 합성한 합성 이벤트(SyntheticEvent)를 제공한다.

```typescript
type EventHandler<Event extends React.SyntheticEvent> = (e: Event) => void | null
type ChangeEventHandler = EventHandler<ChangeEvent<HTMLSelectElement>>

const eventHandler1: GlobalEventHandlers['onchange'] = (e) => {
  e.target // 일반 Event는 target이 없음
}

const eventHandler2: ChangeEventHandler = (e) => {
  e.target // 리액트 이벤트(합성 이벤트)는 target이 있음
}
```

리액트에서 제공하는 기본 컴포넌트도 SelectProps처럼 각각 props에 대한 타입을 명시해두고 있으므로 리액트 컴포넌트에 연결할 이벤트 핸들러로 해당 타입을 일치시켜줘야 한다.

앞의 예시에서 React.ChangeEventHandler<HTMLSelectElement> 타입은 React.EventHandler<ChangeEvent<HTMLSelectElement>>와 동일한 타입이다.

onChange는 HTML의 select 엘리먼트에서 발생하는 change 이벤트에 대한 핸들러로 선언되었다.

이제 우리는 ChangeEvent<HTMLSelectElement> 타입의 이벤트를 매개변수로 받아 해당 이벤트를 처리하는 핸들러를 작성할 수 있게 되었다.

```typescript
const Select = ({ onChange, options, selectedOption }: SelectProps) => {
  const handleChange: React.ChangeEventHandler<HTMLSelectElement> = (e) => {
    const selected = Object.entries(options).find(
      ([_, value]) => value === e.target.value
    )?.[0]
    onChange?.(selected)
  }

  return (
    <select onChange={handleChange}>
      {/* ... */}
    </select>
  )
}
```

## 5. 훅에 타입 추가하기

아래 예시는 Select 컴포넌트를 사용하여 과일을 선택할 수 있는 컴포넌트를 나타낸 것이다.

useState 같은 함수 역시 타입 매개변수를 지정해줌으로써 반환되는 state 타입을 지정해줄 수 있다.

만약 제네릭 타입을 명시하지 않으면 타입스크립트 컴파일러는 초깃값(default value)의 타입을 기반으로 state 타입을 추론한다.

```typescript
const fruits = {
  apple: '사과',
  banana: '바나나',
  blueberry: '블루베리',
}

const FruitSelect: VFC = () => {
  const [fruit, changeFruit] = useState<string | undefined>()

  return (
    <Select onChange={changeFruit} options={fruits} selectedOption={fruit} />
  )
}
```

만약 타입 매개변수가 없다면 fruit의 타입이 undefined로만 추론되면서 onChange의 타입과 일치하지 않아 오류가 발생한다.

다음 예시의 작성자는 fruit가 반드시 apple, banana, blueberry 중 하나라고 기대하고 있을 것이다.

하지만 useState에 제네릭 타입을 지정해주지 않는다면 타입스크립트 컴파일러는 fruit를 string으로 추론할 것이고, 다음에 다른 개발자가 changeFruit에 fruit 타입에 속하지 않는 orange를 넣을 수도 있다.

컴파일러 역시 이를 에러로 잡지 않아 예상치 못한 사이드 이펙트가 발생할 수도 있다.

> **사이드 이펙트(Side Effect)**
>
> 프로그램의 실행 결과가 예상치 못한 상태로 변경되거나 예상치 못한 동작을 하게 되는 상황을 가리킨다.
>
> 즉, 코드의 실행이 예상과 다르게 동작하여 예상치 못한 결과를 초래하는 것을 의미한다.

```typescript
const [fruit, changeFruit] = useState('apple')

// error가 아님
const func = () => {
  changeFruit('orange')
}
```

이럴 때는 타입 매개변수로 좀 더 명확한 타입을 지정함으로써, 다른 개발자가 해당 state나, changeState를 한정된 타입으로만 다룰 수 있게 강제할 수 있다.

```typescript
type Fruit = keyof typeof fruits // 'apple' | 'banana' | 'blueberry'
const [fruit, changeFruit] = useState<Fruit | undefined>('apple')

// 에러 발생
const func = () => {
  changeFruit('orange')
}
```

keyof typeof obj는 해당 객체의 키값을 유니온 타입으로 추출하는 패턴으로 자주 사용된다.

앞의 예시에서는 keyof typeof fruits를 사용하여 fruits 키값만 추출해서 Fruit라는 타입을 새로 만들었다.

그리고 이렇게 정의된 Fruit 타입을 useState의 제네릭으로 활용하여 changeFruit에 'apple', 'banana', 'blueberry', undefined를 제외한 다른 값이 할당되면 에러가 발생하도록 설정되었다.

**이처럼 훅이나 외부 라이브러리 또는 내부 모듈의 함수는 적절한 제네릭 타입을 설정하여 활용할 수 있다.**

string, number, boolean 같은 원시 타입은 자동으로 추론되므로 생략할 수 있다.

## 6. 제네릭 컴포넌트 만들기

```typescript
const FruitSelect = () => {
  const [fruit, changeFruit] = useState<Fruit | undefined>()

  return (
    <Select onChange={changeFruit} options={fruits} selectedOption="orange" />
  )
}
```

selectedOption은 options에 존재하지 않는 값을 받아도 아무런 오류가 발생하지 않는다.

Option의 타입에서 키(key)가 string이기만 하면 prop으로 넘겨줄 수 있기 때문이다.

하지만 changeFruit의 매개변수 Fruit는 prop으로 전달돼야 하는 onChange의 매개변수 타입인 string보다 좁기 때문에 타입 에러가 발생한다.

**Select를 사용하는 입장에서 제한된 키(key)와 값(value)만을 가지도록 하려면 어떻게 해야 할까?**

**함수 컴포넌트 역시 함수이므로 제네릭을 사용한 컴포넌트를 만들어낼 수 있다.**

아래는 객체 형식의 타입을 받아 해당 객체의 키값을 selectedOption, onChange의 매개변수에만 적용하도록 만든 예시이다.

```typescript
interface SelectProps<OptionType extends Record<string, string>> {
  options: OptionType;
  selectedOption?: keyof OptionType;
  onChange?: (selected?: keyof OptionType) => void;
}

const Select = <OptionType extends Record<string, string>>({
  options,
  selectedOption,
  onChange,
}: SelectProps<OptionType>) => {
  // Select component implementation
}
```

Select 컴포넌트에 전달되는 props의 타입 기반으로 타입이 추론되어 <Select<추론된_타입>> 형태의 컴포넌트가 생성된다.

이제 FruitSelect에서 잘못된 selectedOption을 전달하면 타입 에러가 발생한다.

```typescript
const fruits = {
  apple: '사과',
  banana: '바나나',
  blueberry: '블루베리',
}

const FruitSelect: VFC = () => {
  // ...
  // <Select<Fruit> ... /> 으로 작성해도 되지만, 넘겨주는 props의 타입으로 타입 추론을 해줍니다
  // Type Error - Type "orange" is no assignable to type "apple" | "banana" | "blueberry" | undefined
  return (
    <Select options={fruits} onChange={changeFruit} selectedOption="orange" />
  )
}
```

## 7. HTMLAttributes, ReactProps 적용하기

**className, id와 같은 리액트 컴포넌트의 기본 props를 추가하려면 SelectProps에 직접 `className?: string; id?: string;`을 넣어도 되지만 아래처럼 리액트에서 제공하는 타입을 사용하면 더 정확한 타입을 설정할 수 있다.**

```typescript
type ReactSelectProps = React.ComponentPropsWithoutRef<'select'>;

interface SelectProps<OptionType extends Record<string, string>> {
  id?: ReactSelectProps['id'];
  className?: ReactSelectProps['className'];
  // ...
}
```

ReactProps에서 여러 개의 타입을 가져와야 한다면 Pick 키워드를 활용하여 아래처럼 사용할 수도 있다.

```typescript
interface SelectProps<OptionType extends Record<string, string>>
  extends Pick<ReactSelectProps, 'id' | 'key' | /* ... */> {
  // ...
}
```

## 8. styled-components를 활용한 스타일 정의

## 9. 공변성과 반공변성


