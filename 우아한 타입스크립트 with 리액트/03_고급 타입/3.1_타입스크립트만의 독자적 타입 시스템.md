## 1. any 타입

any 타입은 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있다.

any 타입은 타입스크립트로 달성하고자 하는 정적 타이핑을 무색하게 만들 수 있다.

따라서 any 타입을 변수에 할당하는 것은 지양해야 할 패턴으로 알려져 있다.

하지만 타입스크립트에서 any 타입을 어쩔 수 없이 사용해야 할 때가 있는데 대표적으로 3가지 사례를 들 수 있다.

### 개발 단계에서 임시로 값을 지정해야 할 때

매우 복잡한 구성 요소로 이루어진 개발 과정에서 추후 값이 변경될 가능성이 있거나 아직 세부 항목에 대한 타입이 확정되지 않은 경우가 생길 수 있다.

이럴 때 해당 값을 any로 지정하면 경고 없이 개발을 계속할 수 있다.

하지만 any 타입으로 지정하고 나서 다른 타입으로 바꾸는 과정이 누락되면 문제가 발생할 수 있으므로 주의해야 한다.

### 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때

예를 들어 API 요청 및 응답 처리, 콜백 함수 전달, 타입이 잘 정제되지 않아 파악이 힘든 외부 라이브러리 등을 사용할 때는 어떤 인자를 주고받을지 특정하기 힘들다.

이처럼 주고받을 값이 명확하지 않을 때 열린 타입(any 타입)을 선언해야 할 수 있다.

### 값을 예측할 수 없을 때 암묵적으로 사용

외부 라이브러리나 웹 API의 요청에 따라 다양한 값을 반환하는 API가 존재할 수 있다.

대표적인 예로 브라우저의 Fetch API를 들 수 있다.

Fetch API의 일부 메서드는 요청 이후의 응답을 특정 포맷으로 파싱하는데 이때 반환 타입이 any로 매핑되어 있는 것을 볼 수 있다.

## 2. unknown 타입

**unknown 타입은 any 타입과 유사하게 모든 타입의 값이 할당될 수 있다.**

**그러나 any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다.**

```typescript
let unknownValue: unknown

unknownValue = 100
unknownValue = 'hello world'
unknownValue = () => console.log('this is any type')

let someValue1: any = unknownValue
let someValue2: number = unknownValue // Error: Type 'unknown' is not assignable to type 'number'.
let someValue3: string = unknownValue // Error: Type 'unknown' is not assignable to type 'string'.
```

unknown 타입은 이름처럼 무엇이 할당될지 아직 모르는 상태의 타입을 말한다.

이렇게만 보면 any 타입과 비슷한데 왜 unknown 타입이 추가되었을까?

```typescript
// 할당하는 시점에서는 에러가 발생하지 않음
const unknownFunction: unknown = () => console.log('this is unknown type')

// 하지만 실행 시에는 에러가 발생함
unknownFunction() // Error: 'unknownFunction' is of type 'unknown'.
```

**unknown 타입으로 할당된 변수는 어떤 값이든 올 수 있음을 의미하는 동시에, 개발자에게 엄격한 타입 검사를 강제하는 의도를 담고 있다.**

나중에 any 타입을 특정 타입으로 수정해야 하는 것을 깜빡하고 누락하면 어떤 값이든 전달될 수 있기 때문에 런타임에 예상치 못한 버그가 발생할 가능성이 높아진다는 것도 설명했다.

unknown 타입은 이러한 상황을 보완하기 위해 등장한 타입이다.

**타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있기 때문에 any 타입보다 더 안전하다.**

### Q. unknown은 어떨 때 사용할 수 있을까요?

- 배달이팀: 강제 타입 캐스팅을 통해 타입을 전환할 때 사용합니다.
`const env = process.env as unknown as ProcessEnv` 같은 식으로요.

unknown은 모든 타입의 슈퍼타입이라서 타입 캐스팅이 호환된다.

## 3. void 타입

자바스크립트에서는 함수에서 명시적인 반환문을 작성하지 않으면 기본적으로 undefined가 반환된다.

하지만 타입스크립트에서는 void 타입이 사용되는데 이것은 undefined가 아니다.

타입스크립트에서 함수가 어떤 값을 반환하지 않는 경우에는 void를 지정하여 사용한다고 생각하면 된다.

void 타입은 변수에도 할당할 수 있지만 함수가 아닌 값에 대해서는 대부분 무의미하다.

void 타입으로 지정된 변수는 undefined 또는 null 값만 할당할 수 있다.

그런데 만약 tsconfig.json에서 strictNullChecks 옵션이 설정되었거나 컴파일 시 해당 플래그 설정이 실행되는 경우에는 null 값을 할당할 수 없다.

또한 명시적인 의미를 부여하는 관점에서 undefined와 null 타입 키워드를 직접 사용해서 타입을 지정하는 것이 더 바람직하다.

## 4. never 타입

never 타입은 값을 반환할 수 없는 타입을 말한다.

**여기서 값을 반환하지 않는 것과 반환할 수 없는 것을 명확히 구분해야 한다.**

자바스크립트에서 값을 반환할 수 없는 예는 크게 2가지로 나눌 수 있다.

### 에러를 던지는 경우

throw 키워드를 사용하면 런타임에 에러를 발생시킬 수 있는데, 이는 값을 반환하는 것으로 간주하지 않는다.

따라서 특정 함수가 실행 중 마지막에 에러를 던지는 작업을 수행한다면 해당 함수의 반환 타입은 never이다.

### 무한히 함수가 실행되는 경우

드물지만 함수 내에서 무한 루프를 실행하는 경우가 있을 수 있다.

무한 루프는 결국 함수가 종료되지 않음을 의미하기 때문에 값을 반환하지 못한다.

never 타입은 모든 타입의 하위 타입이다.

즉, never 자신을 제외한 어떤 타입도 never 타입에 할당될 수 없다는 것을 의미한다.

심지어 any 타입이라 할지라도 never 타입에 할당될 수 없다.

## 5. Array 타입

배열 타입을 가리키는 Array 키워드는 자바스크립트에서도 Object.prototype.toString.call(...) 연산자를 사용하여 확인할 수 있다.

Object.prototype.toString.call(...) 함수는 객체의 타입을 알아내는 데 사용하는 함수이다.

typeof를 사용하여 타입을 알 수도 있지만, 이 함수를 사용하는 이유는 typeof의 경우 객체 타입을 단순히 object 타입으로 알려주지만, Object.prototype.toString.call(...) 함수는 객체의 인스턴스까지 알려주기 때문이다.

```typescript
const arr = []
console.log(typeof arr) // 'object'
console.log(Object.prototype.toString.call(arr)) // '[object Array]'
```

## 6. enum 타입

enum은 일종의 구조체를 만드는 타입 시스템이다.

enum을 사용해서 열거형을 정의할 수 있는데 열거형은 각각의 멤버를 가지고 있다.

타입스크립트는 명명한 각 멤버의 값을 스스로 추론한다.

기본적인 추론 방식은 숫자 0부터 1씩 늘려가며 값을 할당하는 것이다.

열거형은 관련이 높은 멤버를 모아 문자열 상수처럼 사용하고자 할 때 유용하게 쓸 수 있다.

숫자로만 이루어져 있거나 타입스크립트가 자동으로 추론한 열거형은 안전하지 않은 결과를 낳을 수 있다.

이러한 동작은 막기 위해 const enum으로 열거형을 선언하는 방법이 있다.

이 방식은 역방향으로의 접근을 허용하지 않기 때문에 자바스크립트에서의 객체에 접근하는 것과 유사한 동작을 보장한다.

그러나 const enum으로 열거형을 선언하더라도 숫자 상수로 관리되는 열거형은 선언한 값 이외의 값을 할당하거나 접근할 때 이를 방지하지 못한다.

반면 문자열 상수 방식으로 선언한 열거형은 미리 선언하지 않은 멤버로 접근을 방지한다.

**문자열 상수 방식으로 열거형을 사용하는 것이 숫자 상수 방식보다 더 안전하며 의도하지 않은 값의 할당이나 접근을 방지하는 데 도움이 된다.**

앞서 열거형은 타입 공간과 값 공간에서 모두 사용된다고 말했다.

**열거형은 타입스크립트 코드가 자바스크립트로 변환될 때 즉시 실행 함수(IIFE) 형식으로 변환되는 것을 볼 수 있다.**

**이때 일부 번들러에서 트리쉐이킹 과정 중 즉시 실행 함수로 변환된 값을 사용하지 않는 코드로 인식하지 못하는 경우가 발생할 수 있다.**

따라서 불필요한 코드의 크기가 증가하는 결과를 초래할 수 있다.

**이러한 문제를 해결하기 위해 const enum 또는 as const assertion을 사용해서 유니온 타입으로 열거형과 동일한 효과를 얻는 방법이 있다.**
