## 1. 함수의 제네릭

어떤 함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 때 제네릭을 사용할 수 있다.

## 2. 호출 시그니처의 제네릭

호출 시그니처(call signature)는 타입스크립트의 함수 타입 문법으로 함수의 매개변수와 반환 타입을 미리 선언하는 것을 말한다.

호출 시그니처를 사용함으로써 개발자는 함수 호출 시 필요한 타입을 별도로 지정할 수 있게 된다.

호출 시그니처를 사용할 때 제네릭 타입을 어디에 위치시키는지에 따라 타입의 범위와 제네릭 타입을 언제 구체 타입으로 한정할지를 결정할 수 있다.

```typescript
interface useSelectPaginationProps<T> {
  categoryAtom: RecoilState<number>;
  filterAtom: RecoilState<string[]>;
  sortAtom: RecoilState<SortType>;
  fetcherFunc: (props: CommonListRequest) => Promise<DefaultResponse<ContentListResponse<T>>>;
}
```

이 코드는 우아한형제들 배민선물하기팀의 호출 시그니처 제네릭 활용 예시다.

여기서 `<T>`는 useSelectPaginationProps의 타입 별칭으로 한정했다.

따라서 useSelectPaginationProps을 사용할 때 타입을 명시함으로써 제네릭 타입을 구체 타입으로 한정한다.

그다음 배민커머스웹프론트개발팀의 활용 예시를 보자.

```typescript
export type UseRequesterHookType = <RequestData = void, ResponseData = void>(
  baseURL?: string | Headers,
  defaultHeader?: Headers
) => [RequestStatus, Requester<RequestData, ResponseData>]
```

이 예시에서 <RequestData, ResponseData>는 호출 시그니처의 일부, 다시 말해 괄호(()) 앞에 선언했기 때문에 타입스크립트는 UseRequesterHookType 타입의 함수를 실제 호출할 때 제네릭 타입을 구체 타입으로 한정한다.

## 3. 제네릭 클래스

제네릭 클래스는 외부에서 입력된 타입을 클래스 내부에 적용할 수 있는 클래스이다.

```typescript
class LocalDB<T> {
  // ...
  async put(table: string, row: T): Promise<T> {
    return new Promise<T>((resolved, rejected) => { /* T 타입의 데이터를 DB에 저장 */ })
  }

  async get(table: string, key: any): Promise<T> {
    return new Promise<T>((resolved, rejected) => { /* T 타입의 데이터를 DB에서 가져옴 */ })
  }
}

export default class IndexedDB implements ICacheStore {
  private _DB?: LocalDB<{ key: string; value: Promise<Record<string, unknown>>; cacheTTL: number }>

  private DB() {
    if (!this._DB) {
      this._DB = new LocalDB('localCache', { ver: 6, tables: [{ name: TABLE_NAME, keyPath: 'key' }] })
    }
    return this._DB
  }
  // ...
}
// LocalDB 클래스는 외부에서 { key: string; value: Promise<Record<string, unknown>>; cacheTTL: number } 타입을 받아들여 클래스 내부에서 사용될 제네릭 타입으로 결정된다.
```

클래스 이름 뒤에 타입 매개변수인 `<T>`를 선언해준다.

`<T>`는 메서드의 매개변수나 반환 타입으로 사용될 수 있다.

제네릭 클래스를 사용하면 클래스 전체에 걸쳐 타입 매개변수가 적용된다.

특정 메서드만을 대상으로 제네릭을 적용하려면 해당 메서드를 제네릭 메서드로 선언하면 된다.

## 4. 제한된 제네릭

타입스크립트에서 제한된 제네릭은 타입 매개변수에 대한 제약 조건을 설정하는 기능을 말한다.

예를 들어 string 타입으로 제약하려면 타입 매개변수는 특정 타입을 상속(extends)해야 한다.

```typescript
type ErrorRecord<Key extends string> = Exclude<Key, ErrorCodeType> extends never ? Partial<Record<Key, boolean>> : never
```

이처럼 타입 매개변수가 특정 타입으로 묶였을 때(bind) 키를 바운드 타입 매개변수(bounded type parameters)라고 부른다.

그리고 string을 키의 상한 한계(upper bound)라고 한다.

상속받을 수 있는 타입으로는 기본 타입뿐만 아니라 상황에 따라 인터페이스나 클래스도 사용할 수 있다.

또한 유니온 타입을 상속해서 선언할 수도 있다.

## 5. 확장된 제네릭

제네릭 타입은 여러 타입을 상속받을 수 있으며 타입 매개변수를 여러 개 둘 수도 있다.

```typescript
<Key extends string>

<Key extends string | number>

<Ok, Err = string>
```

## 6. 제네릭 예시

제네릭의 장점은 다양한 타입을 받게 함으로써 코드를 효율적으로 재사용할 수 있는 것이다.

그렇다면 실제 현업에서 가장 많이 제네릭을 활용할 때는 언제일까? 바로 API 응답 값의 타입을 지정할 때이다.

우아한형제들에서는 API 응답 값의 타입을 지정할 때 제네릭을 활용하여 적절한 타입 추론과 코드의 재사용성을 높이고 있다.

```typescript
export interface MobileApiResponse<Data> {
  data: Data;
  statusCode: string;
  statusMessage?: string;
}
```

### 제네릭을 굳이 사용하지 않아도 되는 타입

제네릭이 필요하지 않을 때도 사용하면 코드 길이만 늘어나고 가독성을 해칠 수 있다.

```typescript
type GType<T> = T
type RequirementType = 'USE' | 'UN_USE' | 'NON_SELECT'

interface Order {
  gerRequirement(): GType<RequirementType>;
}
```

Gtype이 다른 곳에서는 사용되지 않고 getRequirement 함수의 반환 값 타입으로만 사용되고 있다고 가정해보자.

Gtype이라는 이름이 현재 사용되고 있는 목적의 의미를 정확히 담고 있지도 않을뿐더러 굳이 제네릭을 사용하지 않고 타입 매개변수를 그대로 선언하는 것과 같은 기능을 하고 있다.

즉, 아래처럼 사용하는 것과 동일하다.

```typescript
type RequirementType = 'USE' | 'UN_USE' | 'NON_SELECT'

interface Order {
  gerRequirement(): RequirementType;
}
```

### any 사용하기

any를 사용하면 제네릭을 포함해 타입을 지정하는 의미가 사라지게 된다.

### 가독성을 고려하지 않은 사용

부득이한 상황을 제외하고 복잡한 제네릭은 의미 단위로 분할해서 사용하는 게 좋다.

만약에 내가 작성한 코드를 다른 개발자가 쉽게 이해하지 못하고 있다면 혹시 제네릭을 오남용하고 있는 것은 아닌지 검토해봐야 한다.
