7가지 원시 타입에 속하지 않는 값은 모두 객체 타입으로 분류할 수 있다.

## 1. object

자바스크립트 객체의 정의에 맞게 이에 대응하는 타입스크립트 타입 시스템은 object 타입이다.

object 타입은 가급적 사용하지 말도록 권장되는데 any 타입과 유사하게 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되기 때문이다.

객체, 배열, 정규 표현식, 함수, 클래스 등 모두 object 타입과 호환된다.

그러나 원시 타입은 호환되지 않는다.

## 2. {}

중괄호({})는 자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용한다.

{} 타입으로 지정된 객체에는 어떤 값도 속성으로 할당할 수 없다.

사실 빈 객체 타입을 지정하기 위해서는 {}보다 유틸리티 타입으로 Record<string, never>처럼 사용하는 게 바람직하다.

{} 타입으로 지정된 객체는 완전히 비어있는 순수한 객체를 의미하는 것이 아니다.

자바스크립트 프로토타입 체이닝으로 Object 객체 래퍼에서 제공하는 속성에는 정상적으로 접근할 수 있다.

타입스크립트에서 객체 래퍼를 타입으로 지정할 수 있는데도 이러한 이유 때문에 소문자로 된 타입스크립트 타입 체계를 사용하는 게 일반적이다.

## 3. array

타입스크립트 배열 타입은 하나의 타입 값만 가질 수 있다는 점에서 자바스크립트 배열보다 조금 더 엄격하다.

하지만 자바스크립트와 마찬가지로 원소 개수는 타입에 영향을 주지 않는다.

타입스크립트에서 배열 타입을 선언하는 방식은 Array 키워드로 선언하거나 대괄호([])를 사용해서 선언하는 방법이 있다.

여기서 주의해야 할 점이 있는데 튜플 타입도 대괄호로 선언한다는 것이다.

타입스크립트 튜플 타입은 배열과 유사하지만 튜플의 대괄호 내부에는 선언 시점에 지정해준 타입 값만 할당할 수 있다.

원소 개수도 타입 선언 시점에 미리 정해진다.

## 4. type과 interface 키워드

타입스크립트 object 타입은 실무에서는 잘 사용하지 않는다.

객체를 타이핑하기 위해서는 타입스크립트에서만 독자적으로 사용할 수 있는 키워드를 사용하는 게 일반적이다.

흔히 객체를 타이핑하기 위해 자주 사용하는 키워드로 type과 interface가 있다.

중괄호를 사용한 객체 리터럴 방식으로 타입을 매번 일일이 지정하기에는 중복적인 요소가 많다.

타입스크립트에서는 일반적으로 변수 타입을 명시적으로 선언하지 않아도 컴파일러가 자동으로 타입을 추론한다.

따라서 모든 변수에 타입을 일일이 명시적으로 선언할 필요가 없다.

## 5. function

자바스크립트에서는 함수도 일종의 객체로 간주하지만 typeof 연산자로 함수 타입을 출력해보면 자바스크립트는 함수를 function이라는 별도 타입으로 분류한다는 것을 확인할 수 있다.

마찬가지로 타입스크립트에서도 함수를 별도 함수 타입으로 지정할 수 있다.

다만 앞서 살펴본 객체의 타이핑과 달리 주의해야 할 점이 있다.

첫째, 자바스크립트에서 typeof 연산자로 확인한 function이라는 키워드 자체를 타입으로 사용하지는 않는다는 것이다.

둘째, 함수는 매개변수 목록을 받을 수 있는데 타입스크립트에서는 매개변수도 별도 타입으로 지정해야 한다.

함수 자체의 타입은 어떻게 지정할 수 있을까? 호출 시그니처를 정의하는 방식을 사용하면 된다.

> **호출 시그니처(Call Signature)**
>
> 타입스크립트에서 함수 타입을 정의할 때 사용하는 문법이다.
>
> 함수 타입은 해당 함수가 받는 매개변수와 반환하는 값의 타입으로 결정된다.
>
> 호출 시그니처는 이러한 함수의 매개변수와 반환 값의 타입을 명시하는 역할을 한다.

```typescript
type add = (a: number, b: number) => number
```

타입스크립트에서 함수 자체의 타입을 명시할 때는 화살표 함수 방식으로만 호출 시그니처를 정의한다.
