## 1. 타입 애너테이션 방식

타입 애너테이션(type annotation)이란 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법이다.

언어마다 타입을 명시해주는 방법은 다르다.

타입스크립트는 변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입을 명시해준다.

```typescript
let isDone: boolean = false
let decimal: number = 6
let color: string = 'blue'
let list: number[] = [1, 2, 3]
let x: [string, number] // tuple
```

## 2. 구조적 타이핑

타입을 사용하는 여러 프로그래밍 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있다.

타입은 이름으로 구분되며 컴파일타임 이후에도 남아있다.

이것을 명목적으로 구체화한 타입 시스템(Nominal Reified Type Systems)이라고 부르기도 한다.

그러나 타입스크립트에서 타입을 구분하는 방식은 조금 다르다.

이름으로 타입을 구분하는 명목적인 타입 언어의 특징과 달리 타입스크립트는 구조로 타입을 구분한다.

이것을 구조적 타이핑(Structural type system)이라고 한다.

```typescript
interface Developer {
  faceValue: number
}

interface BankNote {
  faceValue: number
}

let developer: Developer = { faceValue: 52 }
let bankNote: BankNote = { faceValue: 10000 }

developer = bankNote // OK
bankNote = developer // OK
```

## 3. 구조적 서브타이핑

앞서 타입스크립트의 타입 시스템을 집합으로 이해할 수 있다고 언급했었다.

타입스크립트의 타입은 값의 집합으로 생각할 수 있다.

타입은 단지 집합에 포함되는 값이고 특정 값은 많은 집합에 포함될 수 있다.

따라서 타입스크립트에서는 특정 값이 string 또는 number 타입을 동시에 가질 수 있다.

```typescript
type stringOrNumber: string | number
```

이처럼 집합으로 나타낼 수 있는 타입스크립트의 타입 시스템을 지탱하고 있는 개념이 바로 구조적 서브타이핑이다.

**구조적 서브타이핑이란 객체가 가지고 있는 속성(프로퍼티)을 바탕으로 타입을 구분하는 것이다.**

**이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.**

```typescript
interface Per {
  name: string;
}

interface Cat {
  name: string;
  age: number;
}

let pet: Pet
let cat: Cat = { name: 'Zag', age: 2 }

pet = cat // OK
```

Cat은 Pet과 다른 타입으로 선언되었지만 Pet이 갖고 있는 name이라는 속성을 가지고 있다.

따라서 Cat 타입으로 선언한 cat을 Pet 타입으로 선언한 pet에 할당할 수 있다.

구조적 서브타이핑은 함수의 매개변수에도 적용된다.

```typescript
interface Per {
  name: string;
}

let cat = { name: 'Zag', age: 2 }

function greet(pet: Pet) {
  console.log('Hello, ' + pet.name)
}

greet(cat) // OK
```

greet() 함수의 매개변수에 들어갈 수 있는 값은 Pet 타입으로 제한되어 있다.

그러나 타입을 명시하지 않은 cat 객체를 greet() 함수의 인자로 전달해도 코드는 정상적으로 실행된다.

cat 객체는 Pet 인터페이스가 가지고 있는 name 속성을 가지고 있어 pet.name의 방식으로 name 속성에 접근할 수 있기 때문이다.

타입스크립트의 서브타이핑, 즉 타입의 상속 역시 구조적 타이핑을 기반으로 하고 있다.

클래스를 사용한 다음 예시를 살펴보자.

```typescript
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
}

class Developer {
  name: string;
  age: number;
  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name
    this.age = age
    this.sleepTime = sleepTime
  }
}

function greet(p: Person) {
  console.log(`Hello, I'm ${p.name}`)
}

const developer = new Developer('zig', 20, 7)

greet(developer) // Hello, I'm zig
```

Developer 클래스가 Person 클래스를 상속받지 않았는데도 greet(developer)는 정상적으로 동작한다.

Developer는 Person이 갖고 있는 속성을 가지고 있기 때문이다.

**서로 다른 두 타입 간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다.**

**타입 A가 타입 B의 서브타입이라면 A 타입의 인스턴스는 B 타입이 필요한 곳에 언제든지 위치할 수 있다.**

즉, 타입이 계층 구조로부터 자유롭다.

## 4. 자바스크립트를 닮은 타입스크립트

타입스크립트의 타입 시스템은 구조적 서브타이핑을 사용한다고 했다.

이것은 명목적 타이핑과는 대조적인 타이핑 방식이다.

명목적 타이핑은 타입의 구조가 아닌 타입의 이름만을 가지고 구별하는 것으로 C++, 자바 등에서 사용한다.

명목적 타이핑에서 두 변수는 같은 이름의 데이터 타입으로 선언된 경우에만 서로 호환된다.

앞에서 사용했던 Cat과 Arrow를 자바 코드로 작성해보자.

```typescript
class Cat {
  String name;

  public void hit() {}
}

class Arrow {
  String name;

  public void hit() {}
}

public class Main {
  public static void main(String[] args) {
    Arrow cat = new Cat() // Error: incompatible types: Cat cannot be converted to Arrow
    Cat arrow = new Arrow() // Error: incompatible types: Arrow cannot be converted to Cat
  }
}
```

Cat과 Arrow 클래스는 String 타입의 name 변수와 hit() 메서드를 가지고 있다는 점에서 구조적으로 동일하지만, 각 클래스로 생성한 인스턴스는 서로 호환되지 않는다.

**명목적 타이핑을 채택한 언어에서는 이름으로 타입을 구분하기 때문에 구조가 같더라도 이름이 다르다면 다른 타입으로 취급한다.**

명목적 타이핑은 타입의 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금 더 안전하다.

개발자가 의도한 타입이 아니라면 변수에 타입을 명시하는 과정에서 에러를 내뱉기 때문이다.

즉, 객체의 속성을 다른 객체의 속성과 호환되지 않도록 하여 안전성을 추구한다.

그런데도 타입스크립트가 구조적 타이핑을 채택한 이유는 타입스크립트가 자바스크립트를 모델링한 언어이기 때문이다.

자바스크립트는 본질적으로 덕 타이핑(duck typing)을 기반으로 한다.

덕 타이핑은 어떤 함수의 매개변숫값이 올바르게 주어진다면 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용한다는 개념이다.

**쉬운 사용성과 안전성이라는 두 가지 목표 사이의 균형을 중시하는 타입스크립트에서는 객체 간 속성이 동일하다면 서로 호환되는 구조적 타입 시스템을 제공하여 더욱 편리성을 높였다.**

자바스크립트의 덕 타이핑과 타입스크립트의 구조적 타이핑은 서로 구분되는 타이핑 방식이지만, 실제 사용하는 코드를 보면 차이가 없어 보인다.

두 가지 타이핑 방식 모두 이름으로 타입을 구분하는 명목적 타이핑과는 달리 객체가 가진 속성을 기반으로 타입을 검사하기 때문이다.

**덕 타이핑과 구조적 타이핑의 차이는 타입을 검사하는 시점에 있다.**

**덕 타이핑은 런타임에 타입을 검사하는 반면, 구조적 타이핑은 컴파일타임에 타입체커가 타입을 검사한다.**

덕 타이핑은 주로 동적 타이핑에서, 구조적 타이핑은 정적 타이핑에서 사용된다.

> **덕 타이핑**
>
> 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식이다.
>
> "만약 어떤 새가 오리처럼 걷고, 헤엄치며 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다"

## 5. 구조적 타이핑의 결과

타입스크립트 구조적 타이핑의 특징 때문에 예기치 못한 결과가 나올 때도 있다.

```typescript
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0

  for (const axis of Object.keys(c)) {
    const length = c[axis]
    // Error: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'Cube'.
    // Error: No index signature with a parameter of type 'string' was found on type 'Cube'.

    total += length
  }
}
```

c에 들어올 객체는 Cube의 width, height, depth 이외에도 어떤 속성이든 가질 수 있기 때문에 c[axis]의 타입이 string일 수도 있어 에러가 발생한다.

즉, 아래와 같은 상황이다.

```typescript
const namedCube = {
  width: 6,
  height: 5,
  depth: 4,
  name: 'SweetCube', // string 타입의 추가 속성이 정의되었다
}

addLines(namedCube) // OK
```

타입스크립트는 c[axis]가 어떤 속성을 지닐지 알 수 없으며 c[axis] 타입을 number라고 확정할 수 없어서 에러를 발생시킨다.

**타입스크립트 구조적 타이핑의 특징으로 Cube 타입 값이 들어갈 곳에 name 같은 추가 속성을 가진 객체도 할당할 수 있기 때문에 발생하는 문제다.**

이러한 한계를 극복하고자 타입스크립트에 명목적 타이핑 언어의 특징을 가미한 식별할 수 있는 유니온(Discriminated Unions) 같은 방법이 생겨났다.

## 6. 타입스크립트의 점진적 타입 확인

타입스크립트는 점진적으로 타입을 확인하는(gradually typed) 언어다.

**점진적 타입 검사란 컴파일타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식이다.**

타입을 지정한 변수와 표현식은 정적으로 타입을 검사하지만 타입 선언이 생략되면 동적으로 검사를 수행한다.

타입 선언을 생략하면 암시적 타입 변환이 일어난다.

**타입스크립트에서는 필요에 따라 타입을 생략할 수도 있고 타입을 점진적으로 추가할 수도 있다.**

## 7. 자바스크립트 슈퍼셋으로서의 타입스크립트

**모든 자바스크립트 코드는 타입스크립트라고 볼 수 있지만 반대로 모든 타입스크립트 코드가 자바스크립트 코드인 것은 아니다.**

**타입스크립트는 타입을 명시하는 문법을 가지고 있기 때문이다.**

타입 구문을 사용하는 순간부터 자바스크립트는 타입스크립트의 영역으로 들어가게 된다.

## 8. 값 vs 타입

값(value)은 프로그램이 처리하기 위해 메모리에 저장하는 모든 데이터다.

객체 역시 값이다. 그리고 자바스크립트에서는 함수도 값이다.

모든 것이 객체인 언어답게 자바스크립트 함수는 런타임에 객체로 변환되기 때문이다.

**값은 어떠한 식을 연산(evaluate)한 것으로 변수에 할당할 수 있다.**

**값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있는데 타입스크립트가 자바스크립트의 슈퍼셋인 것과 관련이 있다.**

**타입스크립트 문법인 type으로 선언한 내용은 자바스크립트 런타임에서 제거되기 때문에 값 공간과 타입 공간은 서로 충돌하지 않는다.**

**값과 타입은 타입스크립트에서 별도의 네임스페이스에 존재한다.**

타입스크립트는 개발자가 작성한 코드 문맥을 파악해서 스스로 값 또는 타입으로 해석한다.

**값이 사용되는 위치와 타입이 사용되는 위치가 다르기 때문에, 코드가 어디에서 사용되었는지에 따라 타입인지 값인지를 추론할 수 있다.**

**타입스크립트에는 값과 타입 공간에 동시에 존재하는 심볼도 있다.**

**대표적인 것이 클래스와 enum이다.**

번수명 me 뒤에 등장하는 `: Developer`에서 Developer는 타입에 해당하지만, `new Developer()`에서 new 키워드 뒤의 Developer는 클래스 생성자 함수인 값으로 동작한다.

클래스와 마찬가지로 타입스크립트 문법인 enum 역시 런타임에 객체로 변환되는 값이다.

```typescript
enum Direction {
  Up, // 0
  Down, // 1
  Left, // 2
  Right, // 3
}
```

enum 예시를 순수 자바스크립트 코드로 컴파일하면 다음과 같다.

```javascript
"use strict";
var Direction;
(function (Direction) {
  Direction[(Direction["Up"] = 0)] = "Up";
  Direction[(Direction["Down"] = 1)] = "Down";
  Direction[(Direction["Left"] = 2)] = "Left";
  Direction[(Direction["Right"] = 3)] = "Right";
})(Direction || (Direction = {}));
```

### Q. `enum`, `const enum`, `as const` 중에 뭘 쓰는 게 나을까?

> 1. `enum`은 자바스크립트로 변환될 때 즉시실행함수(IIFE)로 실행되어 객체로 남는다. 런타임에서 실제 값으로도 사용될 수 있다는 장점이 있지만, 트리쉐이킹이 안 된다는 단점이 있다. 트리쉐이킹이 안 되면 번들 사이즈가 늘어날 수 있기 때문이다.

- 배달이팀: 사실 enum을 쓴다고 해서 전체 파일의 번들 사이즈가 서비스에 영향을 미칠정도로 커지지 않으니 크게 고민하지는 않아요.
- 메이팀: enum은 사용하기에는 되게 편한데 자바스크립트로 컴파일될 때 IIFE로 바뀌는 게 크진 않지만 성능에 영향을 줄 수 있다는 것을 본 것 같아서 그 이후로는 습관적으로 안 쓰기 시작했어요.

> 2. `const enum`은 자바스크립트로 변환될 때 참조한 곳에 값이 치환되는 방식이라 트리쉐이킹이 된다는 장점이 있다. 그러나 치환되는 방식으로 인해 빌드된 코드와 런타임의 코드 간 차이가 발생해 버전 문제가 생길 수 있다는 단점이 있다.

- 타입스크립트 프로그래밍 49p: const enum은 기본적으로 아무 자바스크립트도 생성하지 않으며 그 대신 필요한 곳에 열거형 멤버의 값을 채워 넣는다(예를 들어 타입스크립트는 Language.Spanish가 사용된 모든 코드를 값 1로 바꾼다).
- 타입스크립트 프로그래밍 50p: 누군가의 타입스크립트 코드에 정의된 const enum을 가져왔을 때는 이 채워 넣기 기능이 문제를 일으킬 수 있다. 개발자가 타입스크립트 코드를 컴파일한 이후에 열거형을 만든 사람이 자신의 const enum을 갱신하면 런타임에 같은 열거형이 버전에 따라 다른 값을 갖게 되고, 타입스크립트가 이 상황에서 할 수 있는 일은 없다. const enum을 사용할 때는 채워 넣기 기능을 되도록 피해야 하며 여러분이 제어할 수 있는 타입스크립트 프로그램에서만 사용해야 한다. NPM으로 배포하거나 라이브러리로 제공할 프로그램에서는 const enum을 사용하지 말아야 한다.

예를 들어, 어떤 사람이 const enum을 정의하고, 이걸 NPM에 라이브러리로 올린 상황이라고 해보자.

당신은 이 라이브러리를 받아서 LogLevel.Info를 코드에 썼다.

컴파일하면 숫자 1로 대체된다. (채워 넣기 기능)

나중에 enum 정의자가 순서를 바꿨다고 해보자.

```typescript
export const enum LogLevel {
  Debug,
  Warn, // 순서 바뀜
  Info,
  Error,
}
```

이제 Info = 2가 됐다.

그런데 당신은 enum을 여전히 1로 쓰고 있다. (이미 컴파일된 코드니까)

결국 런타임에서 서로 다른 enum 값이 존재하고, 버그가 발생할 수 있다.

> 3. 그래서 난 `as const` 방식을 선호한다. 즉시실행함수로 객체가 생성되지 않는 단순 상수 객체이기 때문에, 모듈 번들러가 CommonJS가 아닌 ESM처럼 트리쉐이킹 지원하는 번들러라면 트리쉐이킹 된다.

## 9. 타입을 확인하는 방법

타입스크립트에서 typeof, instanceof 그리고 타입 단언을 사용해서 타입을 확인할 수 있다.

**타입스크립트에서 typeof 연산자도 값에서 쓰일 때와 타입에서 쓰일 때의 역할이 다르다.**

값에서 사용된 typeof는 자바스크립트 런타임의 typeof 연산자가 된다.

```typescript
interface Person {
  first: string;
  last: string;
}

const person: Person = { first: 'zig', last: 'song' }

function email(options: { person: Person; subject: string; body: string }) {}

const v1 = typeof person // 값은 'object'
const v2 = typeof email // 값은 'function'
```

반면 타입에서 사용된 typeof는 값을 읽고 타입스크립트 타입을 반환한다.

```typescript
type T1 = typeof person // 타입은 Person
type T2 = typeof email // 타입은 (options: { person: Person; subject: string; body: string }) => void
```

자바스크립트 클래스는 typeof 연산자를 쓸 때 주의해야 한다.

```typescript
class Developer {
  name: string;
  sleepingTime: number;

  constructor(name: string, sleepingTime: number) {
    this.name = name
    this.sleepingTime = sleepingTime
  }
}

const d = typeof Developer // 값이 'function'
type T = typeof Developer // 타입이 typeof Developer
```

자바스크립트의 클래스는 결국 함수이기 때문에 값 공간에서 typeof Developer의 값은 function이 된다.

타입 공간에서 typeof Developer의 반환 값은 조금 특이한데 type T에 할당된 Developer는 인스턴스의 타입이 아니라 new 키워드를 사용할 때 볼 수 있는 생성자 함수이기 때문이다.

```typescript
const zig: Developer = new Developer('zig', 7)
type ZigType = typeof zig // 타입이 Developer
```

Developer 클래스로 생성한 zig 인스턴스는 Developer가 인스턴스 타입으로 생성되었기 때문에 타입 공간에서의 typeof zig 즉, type ZigType은 Developer를 반환한다.

그러나 Developer는 Developer 타입의 인스턴스를 만드는 생성자 함수이다.

따라서 typeof Developer 타입도 그 자체인 typeof Developer가 된다.

typeof Developer를 풀어서 설명하면 다음과 같다.

```typescript
new (name: string, sleepingTime: number): Developer
```

**자바스크립트에서 instanceof 연산자를 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있다.**

typeof 연산자처럼 isntanceof 연산자의 필터링으로 타입이 보장된 상태에서 안전하게 값의 타입을 정제하여 사용할 수 있다.

```typescript
let error = unknown

if (error instanceof Error) {
  showAlertModal(error.message)
} else {
  throw Error(error)
}
```

타입스크립트에서는 타입 단언이라 부르는 문법을 사용해서 타입을 강제할 수도 있는데 as 키워드를 사용하면 된다.

타입 단언은 개발자가 해당 값의 타입을 더 잘 파악할 수 있을 때 사용되며 강제 형 변환과 유사한 기능을 제공한다.

이외에도 타입을 검사하는 다른 방법이 있는 타입 카드라는 패턴도 있다.

타입 가드는 특정 조건을 검사해서 타입을 정제하고 타입 안정성을 높이는 패턴이다.
