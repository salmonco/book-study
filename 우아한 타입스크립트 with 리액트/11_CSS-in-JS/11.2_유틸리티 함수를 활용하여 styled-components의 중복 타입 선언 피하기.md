리액트 컴포넌트를 구현할 때 여러 옵션을 props로 받아 유연한 컴포넌트를 구현할 수 있다.

컴포넌트의 background-color, size와 같은 값도 props로 받아와서 상황에 맞는 스타일로 구현하는 경우가 많다.

이때 스타일 관련 props는 styled-components로 전달되는데 해당 타입을 styled-components에서도 정의해줘야 한다.

보통 styled-components에 넘겨주는 타입은 props에서 받은 타입과 동일하다.

이때 타입스크립트에서 제공하는 Pick, Omit 같은 유틸리티 타입을 유용하게 활용할 수 있다.

유틸리티 타입을 활용하지 않을 때는 어떤 불편함이 생기는지 알아보자.

## 1. props 타입과 styled-components 타입의 중복 선언 및 문제점

HrComponent의 props 중 height, color, isFull 속성은 styled-components인 HrComponent에 그대로 prop으로 전달되기 때문에 타입이 같다.

여기서는 아래 코드처럼 height, color, isFull에 대한 StyledProps 타입을 새로 정의하여 HrComponent에 적용했다.

이때 props와 똑같은 타입임에도 StyledProps를 따로 정의해줘야 하는 점 때문에 코드 중복이 발생한다.

또한 props의 height, color, isFull 타입이 변경되면 StyledProps도 변경되어야 한다.

아래 예시의 HrComponent는 간단한 컴포넌트이기 때문에 중복해서 타입을 작성해주는 게 그다지 번거롭지 않을 수 있지만, 컴포넌트가 커지고 여러 styled-components를 활용할 때는 중복되는 타입과 관리해야 되는 포인트가 늘어나게 된다.

**props에서 받은 타입을 styled-components로 넘겨서 활용할 때는 Pick, Omit 같은 유틸리티 타입을 활용할 수 있다.**

```typescript
interface Props {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
  // ...
}

export const Hr: VFC<Props> = ({ height, color, isFull, className }) => {
  // ...
  return (
    <HrComponent
      height={height}
      color={color}
      isFull={isFull}
      className={className}
    />
  )
}

const StyledProps {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
}

const HrComponent = styled.hr<StyledProps>`
  height: ${({ height }) => height || '10px'};
  margin: 0;
  background-color: ${({ color }) => colors[color || 'gray7']};
  border: none;

  ${({ isFull }) =>
    isFull &&
    css`
      margin: 0 -15px;
    `}
`
```

이 코드에서는 Pick 유틸리티 타입을 사용하여 styled-components 타입을 작성했다.

이처럼 styled-components에 적용하는 것뿐만 아니라 상속받는 컴포넌트나 부모 컴포넌트에서 자식 컴포넌트로 넘겨주는 props 등의 경우에도 Pick이나 Omit 같은 유틸리티 타입을 활용하면 중복되는 타입을 피할 수 있어 유지보수적인 측면에서 긍정적인 효과를 얻을 수 있다.

```typescript
const HrComponent = styled.hr<Pick<Props, 'height' | 'color' | 'isFull'>>`
  ...
`
```
