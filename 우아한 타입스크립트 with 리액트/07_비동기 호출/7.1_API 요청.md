## 3. Axios 활용하기

fetch는 내장 라이브러리이기 때문에 따로 임포트하거나 설치할 필요 없이 사용할 수 있다.

그러나 많은 기능을 사용하려면 직접 구현해서 사용해야 한다.

이러한 번거로움 때문에 fetch 함수를 직접 쓰는 대신 Axios 라이브러리를 사용하고 있다.

각 서버(주문을 처리하는 서버와 장바구니를 처리하는 서버)가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하는 API Entry(Base URL)와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.

이렇게 API Entry가 2개 이상일 경우에는 각 서버의 기본 URL을 호출하도록 orderApiRequester, orderCartApiRequester같이 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성해야 한다.

이후 다른 URL로 서비스 코드를 호출할 때는 각각의 apiRequester를 사용하면 된다.

## 4. Axios 인터셉터 사용하기

각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 다른 헤더를 설정해줘야 하는 로직이 필요할 수도 있다.

이때 인터셉터 기능을 사용하여 requester에 따라 비동기 호출 내용을 추가해서 처리할 수 있다.

또한 API 에러를 처리할 때 하나의 에러 객체로 묶어서 처리할 수도 있다.

요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBuilder 같은 클래스 형태로 구성하기도 한다.

```typescript
const fetchJobNameList = async (name?: string, size?: number) => {
  const api = APIBuilder.get("/apis/web/jobs")
    .withCredentials(true) // 이제 401 에러가 나는 경우, 자동으로 에러를 탐지하는 인터셉터를 사용하게 된다
    .params({ name, size }) // body가 없는 axios 객체도 빌더 패턴으로 쉽게 만들 수 있다
    .build();

  const { data } = await api.call<Response<JobNameListResponse>>();
  return data;
}
```

APIBuilder 클래스는 보일러플레이트 코드가 많다는 단점을 갖고 있다.

하지만 옵션이 다양한 경우에 인터셉터를 설정값에 따라 적용하고, 필요 없는 인터셉터를 선택적으로 사용할 수 있다는 장점도 갖고 있다.
