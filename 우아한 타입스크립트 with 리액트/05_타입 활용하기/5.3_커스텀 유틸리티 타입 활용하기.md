## 2. PickOne 유틸리티 함수

### 식별할 수 있는 유니온으로 객체 타입을 유니온으로 받기

```typescript
// Tagged Union
type Card = {
  type: 'card';
  card: string;
}
type Account = {
  type: 'account';
  account: string;
}

const withdraw = (type: Card | Account) => {
  // ...
}

withdraw({ type: 'card', card: "ji" })
withdraw({ type: 'account', account: "su" })
```

식별할 수 있는 유니온으로 문제를 해결할 수 있지만 일일이 type을 다 넣어줘야 하는 불편함이 생긴다.

### PickOne 커스텀 유틸리티 타입 구현하기

구현하고자 하는 타입은 account 또는 card 속성 하나만 존재하는 객체를 받는 타입이다.

처음에 작성한 것처럼 { account: string } | { card: string }으로 타입을 구현했을 때는 account와 card 속성을 모두 가진 객체도 허용되는 문제가 있었다.

이때 옵셔널 + undefined로 타입을 지정하면 사용자가 의도적으로 undefined 값을 넣지 않는 이상, 원치 않는 속성에 값을 넣었을 때 타입 에러가 발생할 것이다.

```typescript
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>
}[keyof T]

type Card = {
  card: string;
}
type Account = {
  account: string;
}
type CardOrAccount = PickOne<Card & Account>

const withdraw = (type: CardOrAccount) => {
  // ...
}

withdraw({ card: 'ji' })
withdraw({ account: 'su' })
withdraw({ card: 'ji', account: 'su' }) // Error: Type 'string' is not assignable to type 'undefined'.
```

이렇듯 유틸리티 타입만으로는 원하는 타입을 추출하기 어려울 때 커스텀 유틸리티 타입을 구현한다.
