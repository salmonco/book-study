## 2. PickOne 유틸리티 함수

### 식별할 수 있는 유니온으로 객체 타입을 유니온으로 받기

```typescript
// Tagged Union
type Card = {
  type: 'card';
  card: string;
}
type Account = {
  type: 'account';
  account: string;
}

const withdraw = (type: Card | Account) => {
  // ...
}

withdraw({ type: 'card', card: "ji" })
withdraw({ type: 'account', account: "su" })
```

식별할 수 있는 유니온으로 문제를 해결할 수 있지만 일일이 type을 다 넣어줘야 하는 불편함이 생긴다.

### PickOne 커스텀 유틸리티 타입 구현하기

구현하고자 하는 타입은 account 또는 card 속성 하나만 존재하는 객체를 받는 타입이다.

처음에 작성한 것처럼 { account: string } | { card: string }으로 타입을 구현했을 때는 account와 card 속성을 모두 가진 객체도 허용되는 문제가 있었다.

이때 옵셔널 + undefined로 타입을 지정하면 사용자가 의도적으로 undefined 값을 넣지 않는 이상, 원치 않는 속성에 값을 넣었을 때 타입 에러가 발생할 것이다.

```typescript
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>
}[keyof T]

type Card = {
  card: string;
}
type Account = {
  account: string;
}
type CardOrAccount = PickOne<Card & Account>

const withdraw = (type: CardOrAccount) => {
  // ...
}

withdraw({ card: 'ji' })
withdraw({ account: 'su' })
withdraw({ card: 'ji', account: 'su' }) // Error: Type 'string' is not assignable to type 'undefined'.
```

이렇듯 유틸리티 타입만으로는 원하는 타입을 추출하기 어려울 때 커스텀 유틸리티 타입을 구현한다.

## 3. NonNullable 타입 검사 함수를 사용하여 간편하게 타입 가드하기

일반적으로 if문을 사용해서 null 처리 타입 가드를 적용하지만, is 키워드와 NonNullable 타입으로 타입 검사를 위한 유틸 함수를 만들어서 사용할 수도 있다.

### NonNullable 타입이란

타입스크립트에서 제공하는 유틸리티 타입이다.

NonNullable을 사용하면 null이나 undefined가 아닌 경우를 제외할 수 있다.

```typescript
type NonNullable<T> = T extends null | undefined ? never : T;
```

### null, undefiend를 검사해주는 NonNullable 함수

NonNullable 유틸리티 타입을 사용하여 null 또는 undefined를 검사해주는 타입 가드 함수를 만들어 쓸 수 있다.

```typescript
function NonNullable<T>(value: T): value is NonNullable<T> {
    return value !== null && value !== undefined;
}
```

### Promise.all을 사용할 때 NonNullable 적용하기

여러 상품의 광고를 조회할 때 하나의 API에서 에러가 발생한다고 해서 전체 광고가 보이지 않으면 안 된다.

따라서 try-catch문을 사용하여 에러가 발생할 때는 null을 반환하고 있다.

```typescript
class AdCampaignAPI {
    static async operating(shopNo: number): Promise<AdCampaign[]> {
        try {
            return await fetch(`/ad/shopNumber=${shopNo}`);
        } catch (error) {
            return null;
        }
    }
}

const shopList = [
    { shopNo: 100, category: 'chicken' },
    { shopNo: 101, category: 'pizza' },
    { shopNo: 102, category: 'noodle' },
]

const shopAdCampaignList = await Promise.all(shopList.map((shop) => AdCampaignAPI.operating(shop.shopNo)))

const shopAds = shopAdCampaignList.filter(NonNullable)
```

shopAdCampaignList 변수를 NonNullable 함수로 필터링하지 않으면 shopAdCampaignList를 순회할 때(예: map이나 forEach 같은 순회 메서드를 사용할 때)마다 고차 함수 내 콜백 함수에서 if문을 사용한 타입 가드를 반복하게 된다.

또는 NonNullable 함수를 사용하지 않고 단순하게 필터링한다면 [shopAdCampaignList.filter((shop) => !!shop)]가 원하는 Array<AdCampaign[]> 타입으로 추론되는 것이 아니라, null이 될 수 있는 상태인 Array<AdCampaign[] | null>로 추론된다.
