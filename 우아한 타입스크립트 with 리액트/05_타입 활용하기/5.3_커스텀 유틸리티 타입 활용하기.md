타입스크립트로 프로젝트를 진행하다 보면 표현하기 힘든 타입을 마주할 때가 있다.

원하는 타입을 정확하게 설정해야만 해당 컴포넌트, 함수의 안정성과 사용성을 높일 수 있지만 타입스크립트에서 제공하는 유틸리티 타입만으로는 표현하는 데 한계를 느끼기도 한다.

이럴 때는 유틸리티 타입을 활용한 커스텀 유틸리티 타입을 제작해서 사용하면 된다.

## 1. 유틸리티 함수를 활용해 styled-components의 중복 타입 선언 피하기

리액트 컴포넌트를 구현할 때 여러 옵션을 props로 받아 유연한 컴포넌트로 만들 수 있다.

예를 들어 컴포넌트의 background-color, size 값을 props로 받아와서 상황에 맞게 스타일을 구현할 때가 많다.

이와 같은 스타일 관련 props는 styled-components에 전달되며 styled-components에도 해당 타입을 정확하게 작성해줘야 한다.

styled-components로 만든 컴포넌트에 넘겨주는 타입은 props에서 받은 타입과 동일할 때가 대부분이다.

이런 경우에는 타입스크립트에서 제공하는 Pick, Omit 같은 유틸리티 타입을 잘 활용하여 코드를 간결하게 작성할 수 있다.

### Props 타입과 styled-components 타입의 중복 선언 및 문제점

아래 컴포넌트는 수평선을 그어주는 Hr 컴포넌트다.

```typescript
// HrComponent.tsx
export type Props = {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
  // ...
}

export const Hr: VFC<Props> = ({ height, color, isFull, className }) => {
  // ...
  return <HrComponent height={height} color={color} isFull={isFull} className={className} />
}

// style.ts
import { Props } from '...'

type StyledProps = Pick<Props, 'height' | 'color' | 'isFull'>

const HrComponent = styled.hr<StyledProps>`
  height: ${({ height }) => height || '10px'};
  margin: 0;
  background-color: ${({ color }) => colors[color || 'gray7']};
  border: none;
  ${({ isFull }) => isFull && css`
    margin: 0 -15px;
  `}
`
```

**Hr 컴포넌트 Props의 height, color, isFull 속성은 styled-components 컴포넌트인 HrComponent에 바로 연결되며 타입도 역시 같다.**

**StyledProps를 따로 정의하려면 Props와 똑같은 타입임에도 새로 작성해야 하므로 불가피하게 중복된 코드가 생긴다.**

**그리고 Props의 height, color, isFull 타입이 변경되면 StyledProps도 같이 변경돼야 한다.**

Hr 컴포넌트가 간단한 컴포넌트이기 때문에 코드를 중복해서 작성하는 게 별로 번거롭지 않을 수도 있지만, 컴포넌트가 더 커지고 styled-components로 만든 컴포넌트가 늘어날수록 중복되는 타입이 많아지며 관리해야 하는 포인트도 늘어난다.

**이런 문제를 Pick, Omit 같은 유틸리티 타입으로 개선할 수 있다.**

**Pick 유틸리티 타입을 활용해서 props에서 필요한 부분만 선택하여 styled-components 컴포넌트의 타입을 정의하면, 중복된 코드를 작성하지 않아도 되고 유지보수를 더욱 편리하게 할 수 있게 된다.**

이외에도 상속받는 컴포넌트 혹은 부모 컴포넌트에서 자식 컴포넌트로 넘겨주는 props 등에도 Pick, Omit 같은 유틸리티 타입을 활용할 수 있다.

## 2. PickOne 유틸리티 함수

타입스크립트에는 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 진행되지 않는 이슈가 있다.

이런 문제를 해결하기 위해 PickOne이라는 이름의 유틸리티 함수를 구현해보자.

아래 코드와 같이 Card, Account 중 하나의 객체만 받고 싶은 상황에서 Card | Account로 타입을 작성하면 의도한 대로 타입 검사가 이뤄지지 않는다.

또한 withdraw 함수의 인자로 { card: 'hyundai' } 또는 { account: 'hana' } 중 하나만 받고 싶지만 실제로는 card, account 속성을 모두 받아도 타입 에러가 발생하지 않는다.

```typescript
type Card = {
  card: string;
}
type Account = {
  account: string;
}

function withdraw(type: Card | Account) {
  // ...
}

withdraw({ card: 'hyundai', account: 'hana' })
```

왜 타입 에러가 발생하지 않을까?

그 이유는 집합 관점으로 볼 때 유니온은 합집합이 되기 때문이다.

**따라서 card, account 속성이 하나씩만 할당된 상태도 허용하지만 card, account 속성이 모두 포함되어도 합집합의 범주에 들어가기 때문에 타입 에러가 발생하지 않는 것이다.**

**이런 문제를 해결하기 위해 타입스크립트에서는 식별할 수 있는 유니온 기법을 자주 활용한다.**

### 식별할 수 있는 유니온으로 객체 타입을 유니온으로 받기

식별할 수 있는 유니온은 각 타입에 type이라는 공통된 속성을 추가하여 구분짓는 방법이다.

아래 예시에서 Card, Account 타입을 구분할 수 있도록 type이라는 속성이 추가된 것을 볼 수 있다.

식별할 수 있는 유니온을 활용하면 공통된 속성인 type을 기준으로 객체를 구분할 수 있기 때문에 withdraw 함수를 사용하는 곳에서 정확한 타입을 추론할 수 있게 된다.

```typescript
// Tagged Union
type Card = {
  type: 'card';
  card: string;
}
type Account = {
  type: 'account';
  account: string;
}

const withdraw = (type: Card | Account) => {
  // ...
}

withdraw({ type: 'card', card: 'hyundai' })
withdraw({ type: 'account', account: 'hana' })
```

**식별할 수 있는 유니온으로 문제를 해결할 수 있지만 일일이 type을 다 넣어줘야 하는 불편함이 생긴다.**

**처음부터 식별할 수 있는 유니온 형태로 설계했다면 불편함은 덜했을 수도 있지만, 이미 구현된 상태에서 식별할 수 있는 유니온을 적용하려면 해당 함수를 사용하는 부분을 모두 수정해야 한다.**

실수로 수정하지 않은 부분이 생긴다면 또 다른 문제가 발생할 수 있다.

이러한 상황을 방지하기 위해 PickOne이라는 유틸리티 타입을 구현하여 적용해보자.

### PickOne 커스텀 유틸리티 타입 구현하기

**구현하고자 하는 타입은 account 또는 card 속성 하나만 존재하는 객체를 받는 타입이다.**

처음에 작성한 것처럼 { account: string } 또는 { card: string }으로 타입을 구현했을 때는 account와 card 속성을 모두 가진 객체도 허용되는 문제가 있었다.

account일 때는 card를 받지 못하고, card일 때는 account를 받지 못하게 하려면 하나의 속성이 들어왔을 때 다른 타입을 옵셔널한 undefined 값으로 지정하는 방법을 생각해볼 수 있다.

**옵셔널 + undefined로 타입을 지정하면 사용자가 의도적으로 undefined 값을 넣지 않는 이상, 원치 않는 속성에 값을 넣었을 때 타입 에러가 발생할 것이다.**

```typescript
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>
}[keyof T]

type Card = {
  card: string;
}
type Account = {
  account: string;
}
type CardOrAccount = PickOne<Card & Account>

const withdraw = (type: CardOrAccount) => {
  // ...
}

withdraw({ card: 'hyundai' })
withdraw({ account: 'hana' })
withdraw({ card: 'hyundai', account: 'hana' }) // Error: Type 'string' is not assignable to type 'undefined'.
```

**결국 선택하고자 하는 하나의 속성을 제외한 나머지 값을 옵셔널 타입 + undefined로 설정하면 원하고자 하는 속성만 받도록 구현할 수 있다.**

**이렇듯 유틸리티 타입만으로는 원하는 타입을 추출하기 어려울 때 커스텀 유틸리티 타입을 구현한다.**

## 3. NonNullable 타입 검사 함수를 사용하여 간편하게 타입 가드하기

일반적으로 if문을 사용해서 null 처리 타입 가드를 적용하지만, is 키워드와 NonNullable 타입으로 타입 검사를 위한 유틸 함수를 만들어서 사용할 수도 있다.

### NonNullable 타입이란

타입스크립트에서 제공하는 유틸리티 타입이다.

NonNullable을 사용하면 null이나 undefined가 아닌 경우를 제외할 수 있다.

```typescript
type NonNullable<T> = T extends null | undefined ? never : T;
```

### null, undefiend를 검사해주는 NonNullable 함수

NonNullable 유틸리티 타입을 사용하여 null 또는 undefined를 검사해주는 타입 가드 함수를 만들어 쓸 수 있다.

```typescript
function NonNullable<T>(value: T): value is NonNullable<T> {
    return value !== null && value !== undefined;
}
```

### Promise.all을 사용할 때 NonNullable 적용하기

여러 상품의 광고를 조회할 때 하나의 API에서 에러가 발생한다고 해서 전체 광고가 보이지 않으면 안 된다.

따라서 try-catch문을 사용하여 에러가 발생할 때는 null을 반환하고 있다.

```typescript
class AdCampaignAPI {
  static async operating(shopNo: number): Promise<AdCampaign[]> {
    try {
      return await fetch(`/ad/shopNumber=${shopNo}`);
    } catch (error) {
      return null;
    }
  }
}

const shopList = [
  { shopNo: 100, category: 'chicken' },
  { shopNo: 101, category: 'pizza' },
  { shopNo: 102, category: 'noodle' },
]

const shopAdCampaignList = await Promise.all(shopList.map((shop)
  => AdCampaignAPI.operating(shop.shopNo))
)

const shopAds = shopAdCampaignList.filter(NonNullable)
```

shopAdCampaignList 변수를 NonNullable 함수로 필터링하지 않으면 shopAdCampaignList를 순회할 때(예: map이나 forEach 같은 순회 메서드를 사용할 때)마다 고차 함수 내 콜백 함수에서 if문을 사용한 타입 가드를 반복하게 된다.

또는 NonNullable 함수를 사용하지 않고 단순하게 필터링한다면 [shopAdCampaignList.filter((shop) => !!shop)]가 원하는 Array<AdCampaign[]> 타입으로 추론되는 것이 아니라, null이 될 수 있는 상태인 Array<AdCampaign[] | null>로 추론된다.

NonNullable를 사용해서 shopAdCampaignList를 필터링하면 shopAds는 원하는 타입인 Array<AdCampaign[]>로 추론할 수 있게 된다.
